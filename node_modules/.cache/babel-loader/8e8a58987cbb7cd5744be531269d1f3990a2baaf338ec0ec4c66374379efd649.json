{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TopK, util } from '@tensorflow/tfjs-core';\nimport { topKImplCPU } from '../kernel_utils/shared';\nimport { MergeProgram, SwapProgram } from '../top_k_webgpu';\nimport { fill } from './Fill';\nimport { gatherV2 } from './GatherV2';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nfunction disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeData(tensorInfo.dataId);\n  }\n}\nfunction roundUpToPow2(num) {\n  let pow2 = 1;\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n  return pow2;\n}\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\nexport function topK(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    k,\n    sorted\n  } = attrs;\n  const xShape = x.shape;\n  const lastDim = xShape[xShape.length - 1];\n  if (backend.shouldExecuteOnCPU([x])) {\n    const xVals = backend.readSync(x.dataId);\n    const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k, sorted);\n    return [backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values), backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)];\n  }\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [backend.makeTensorInfo(xShape, x.dtype, []), backend.makeTensorInfo(xShape, 'int32', [])];\n  }\n  if (lastDim === 1 /* firstPass */) {\n    return [x, fill({\n      attrs: {\n        shape: xShape,\n        dtype: 'int32',\n        value: 0\n      },\n      backend\n    })];\n  }\n  // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n  const xSize = util.sizeFromShape(xShape);\n  const batch = xSize / lastDim;\n  const x2D = reshape({\n    inputs: {\n      x\n    },\n    attrs: {\n      shape: [batch, lastDim]\n    },\n    backend\n  });\n  const kPow2 = roundUpToPow2(k);\n  const lastDimPow2 = roundUpToPow2(lastDim);\n  // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n  let indices = null;\n  // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];\n  const runSwap = (dir, inc, shape) => {\n    const inputs = getInputs();\n    const program = new SwapProgram(shape);\n    const firstPass = indices === null ? 1 : 0;\n    const uniformDataSwap = [{\n      type: 'int32',\n      data: [lastDim]\n    }, {\n      type: 'int32',\n      data: [firstPass]\n    }, {\n      type: 'float32',\n      data: [Number.NEGATIVE_INFINITY]\n    }, {\n      type: 'int32',\n      data: [dir]\n    }, {\n      type: 'int32',\n      data: [inc]\n    }];\n    const prevIndices = indices;\n    indices = backend.runWebGPUProgram(program, inputs, 'int32', uniformDataSwap);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  };\n  // Step 1: local sort\n  for (let len = 1; len < kPow2; len *= 2) {\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  }\n  // Step 2: merge\n  for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    const inputs = getInputs();\n    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    const firstPass = indices === null ? 1 : 0;\n    const uniformDataMerge = [{\n      type: 'int32',\n      data: [lastDim]\n    }, {\n      type: 'int32',\n      data: [firstPass]\n    }, {\n      type: 'int32',\n      data: [kPow2]\n    }];\n    const prevIndices = indices;\n    indices = backend.runWebGPUProgram(mergeProgram, inputs, 'int32', uniformDataMerge);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n    // Step 3: rebuild\n    const len = kPow2 / 2;\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, indices.shape);\n    }\n  }\n  // Keep only the requested top K results instead of kPow2\n  let prevIndices = indices;\n  indices = slice({\n    inputs: {\n      x: indices\n    },\n    backend,\n    attrs: {\n      begin: 0,\n      size: [batch, k]\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  // Gather values on last dimension\n  let values = gatherV2({\n    inputs: {\n      x: x2D,\n      indices\n    },\n    backend,\n    attrs: {\n      axis: 1,\n      batchDims: 1\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, x2D);\n  // Reshape back to the original input shape, except that the last\n  // dimension is k.\n  const newShape = xShape.slice(0, -1);\n  newShape.push(k);\n  prevIndices = indices;\n  indices = reshape({\n    inputs: {\n      x: indices\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  const prevValues = values;\n  values = reshape({\n    inputs: {\n      x: values\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n  return [values, indices];\n}\nexport const topKConfig = {\n  kernelName: TopK,\n  backendName: 'webgpu',\n  kernelFunc: topK\n};","map":{"version":3,"names":["TopK","util","topKImplCPU","MergeProgram","SwapProgram","fill","gatherV2","reshape","slice","disposeIntermediateTensorInfoOrNull","backend","tensorInfo","disposeData","dataId","roundUpToPow2","num","pow2","topK","args","inputs","attrs","x","k","sorted","xShape","shape","lastDim","length","shouldExecuteOnCPU","xVals","readSync","allTopKVals","allTopKIndices","dtype","makeTensorInfo","values","value","xSize","sizeFromShape","batch","x2D","kPow2","lastDimPow2","indices","getInputs","runSwap","dir","inc","program","firstPass","uniformDataSwap","type","data","Number","NEGATIVE_INFINITY","prevIndices","runWebGPUProgram","len","indicesSize","mergeProgram","uniformDataMerge","begin","size","axis","batchDims","newShape","push","prevValues","topKConfig","kernelName","backendName","kernelFunc"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/kernels/TopK.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, NumericDataType, TensorInfo, TopK, TopKAttrs, TopKInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {topKImplCPU} from '../kernel_utils/shared';\nimport {MergeProgram, SwapProgram} from '../top_k_webgpu';\nimport {fill} from './Fill';\nimport {gatherV2} from './GatherV2';\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nfunction disposeIntermediateTensorInfoOrNull(\n    backend: WebGPUBackend, tensorInfo: TensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeData(tensorInfo.dataId);\n  }\n}\n\nfunction roundUpToPow2(num: number) {\n  let pow2 = 1;\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n  return pow2;\n}\n\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\nexport function topK(\n    args: {inputs: TopKInputs, backend: WebGPUBackend, attrs: TopKAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {k, sorted}= attrs;\n\n  const xShape = x.shape;\n  const lastDim = xShape[xShape.length - 1];\n\n  if (backend.shouldExecuteOnCPU([x])) {\n    const xVals = backend.readSync(x.dataId) as TypedArray;\n    const [allTopKVals, allTopKIndices] =\n        topKImplCPU(xVals, xShape, x.dtype as NumericDataType, k, sorted);\n\n    return [\n      backend.makeTensorInfo(\n          allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n      backend.makeTensorInfo(\n          allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n    ];\n  }\n\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [\n      backend.makeTensorInfo(xShape, x.dtype, []),\n      backend.makeTensorInfo(xShape, 'int32', [])\n    ];\n  }\n\n  if (lastDim === 1 /* firstPass */) {\n    return [\n      x, fill({attrs: {shape: xShape, dtype: 'int32', value: 0}, backend})\n    ];\n  }\n\n  // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n  const xSize = util.sizeFromShape(xShape);\n  const batch = xSize / lastDim;\n  const x2D = reshape({inputs: {x}, attrs: {shape: [batch, lastDim]}, backend});\n\n  const kPow2 = roundUpToPow2(k);\n  const lastDimPow2 = roundUpToPow2(lastDim);\n\n  // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n  let indices: TensorInfo = null;\n\n  // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];\n\n  const runSwap = (dir: number, inc: number, shape: number[]) => {\n    const inputs = getInputs();\n    const program = new SwapProgram(shape);\n    const firstPass = indices === null ? 1 : 0;\n    const uniformDataSwap = [\n        {type: 'int32', data: [lastDim]},\n        {type: 'int32', data: [firstPass]},\n        {type: 'float32', data: [Number.NEGATIVE_INFINITY]},\n        {type: 'int32', data: [dir]},\n        {type: 'int32', data: [inc]}\n    ];\n    const prevIndices = indices;\n    indices = backend.runWebGPUProgram(\n        program, inputs, 'int32', uniformDataSwap);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  };\n\n  // Step 1: local sort\n  for (let len = 1; len < kPow2; len *= 2) {\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  }\n\n  // Step 2: merge\n  for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    const inputs = getInputs();\n    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    const firstPass = indices === null ? 1 : 0;\n    const uniformDataMerge = [\n        {type: 'int32', data: [lastDim]},\n        {type: 'int32', data: [firstPass]},\n        {type: 'int32', data: [kPow2]}\n    ];\n    const prevIndices = indices;\n    indices = backend.runWebGPUProgram(\n        mergeProgram, inputs, 'int32', uniformDataMerge);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n    // Step 3: rebuild\n    const len = kPow2 / 2;\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, indices.shape);\n    }\n  }\n\n  // Keep only the requested top K results instead of kPow2\n  let prevIndices = indices;\n  indices = slice(\n      {inputs: {x: indices}, backend, attrs: {begin: 0, size: [batch, k]}});\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n  // Gather values on last dimension\n  let values = gatherV2(\n      {inputs: {x: x2D, indices}, backend, attrs: {axis: 1, batchDims: 1}});\n  disposeIntermediateTensorInfoOrNull(backend, x2D);\n\n  // Reshape back to the original input shape, except that the last\n  // dimension is k.\n  const newShape = xShape.slice(0, -1);\n  newShape.push(k);\n\n  prevIndices = indices;\n  indices = reshape({inputs: {x: indices}, attrs: {shape: newShape}, backend});\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n  const prevValues = values;\n  values = reshape({inputs: {x: values}, attrs: {shape: newShape}, backend});\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n\n  return [values, indices];\n}\n\nexport const topKConfig: KernelConfig = {\n  kernelName: TopK,\n  backendName: 'webgpu',\n  kernelFunc: topK as unknown as KernelFunc\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}