{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class TextureManager {\n  constructor(device) {\n    this.device = device;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this.freeTextures = new Map();\n    this.usedTextures = new Map();\n    this.numBytesUsed = 0;\n    this.numBytesAllocated = 0;\n  }\n  acquireTexture(width, height, format, usage) {\n    const bytesPerElement = getBytesPerElement(format);\n    const byteSize = width * height * bytesPerElement;\n    const key = getTextureKey(width, height, format, usage);\n    if (!this.freeTextures.has(key)) {\n      this.freeTextures.set(key, []);\n    }\n    if (!this.usedTextures.has(key)) {\n      this.usedTextures.set(key, []);\n    }\n    this.numBytesUsed += byteSize;\n    this.numUsedTextures++;\n    if (this.freeTextures.get(key).length > 0) {\n      this.numFreeTextures--;\n      const newTexture = this.freeTextures.get(key).shift();\n      this.usedTextures.get(key).push(newTexture);\n      return newTexture;\n    }\n    this.numBytesAllocated += byteSize;\n    const newTexture = this.device.createTexture({\n      size: [width, height],\n      format,\n      usage\n    });\n    this.usedTextures.get(key).push(newTexture);\n    return newTexture;\n  }\n  releaseTexture(texture) {\n    if (this.freeTextures.size === 0) {\n      return;\n    }\n    const width = texture.width;\n    const height = texture.height;\n    const format = texture.format;\n    const usage = texture.usage;\n    const key = getTextureKey(width, height, format, usage);\n    if (!this.freeTextures.has(key)) {\n      this.freeTextures.set(key, []);\n    }\n    this.freeTextures.get(key).push(texture);\n    this.numFreeTextures++;\n    this.numUsedTextures--;\n    const textureList = this.usedTextures.get(key);\n    const textureIndex = textureList.indexOf(texture);\n    if (textureIndex < 0) {\n      throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n    }\n    textureList.splice(textureIndex, 1);\n    const bytesPerElement = getBytesPerElement(format);\n    const byteSize = width * height * bytesPerElement;\n    this.numBytesUsed -= byteSize;\n  }\n  getNumUsedTextures() {\n    return this.numUsedTextures;\n  }\n  getNumFreeTextures() {\n    return this.numFreeTextures;\n  }\n  dispose() {\n    this.freeTextures.forEach((textures, key) => {\n      textures.forEach(texture => {\n        texture.destroy();\n      });\n    });\n    this.usedTextures.forEach((textures, key) => {\n      textures.forEach(texture => {\n        texture.destroy();\n      });\n    });\n    this.freeTextures = new Map();\n    this.usedTextures = new Map();\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this.numBytesUsed = 0;\n    this.numBytesAllocated = 0;\n  }\n}\nfunction getTextureKey(width, height, format, usage) {\n  return `${width}_${height}_${format}_${usage}`;\n}\nfunction getBytesPerElement(format) {\n  if (format === 'rgba8unorm') {\n    return 16;\n  } else {\n    throw new Error(`${format} is not supported!`);\n  }\n}","map":{"version":3,"names":["TextureManager","constructor","device","numUsedTextures","numFreeTextures","freeTextures","Map","usedTextures","numBytesUsed","numBytesAllocated","acquireTexture","width","height","format","usage","bytesPerElement","getBytesPerElement","byteSize","key","getTextureKey","has","set","get","length","newTexture","shift","push","createTexture","size","releaseTexture","texture","textureList","textureIndex","indexOf","Error","splice","getNumUsedTextures","getNumFreeTextures","dispose","forEach","textures","destroy"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/texture_manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private freeTextures: Map<string, GPUTexture[]> = new Map();\n  private usedTextures: Map<string, GPUTexture[]> = new Map();\n\n  public numBytesUsed = 0;\n  public numBytesAllocated = 0;\n\n  constructor(private device: GPUDevice) {}\n\n  acquireTexture(\n      width: number, height: number, format: GPUTextureFormat,\n      usage: GPUTextureUsageFlags) {\n    const bytesPerElement = getBytesPerElement(format);\n    const byteSize = width * height * bytesPerElement;\n    const key = getTextureKey(width, height, format, usage);\n    if (!this.freeTextures.has(key)) {\n      this.freeTextures.set(key, []);\n    }\n\n    if (!this.usedTextures.has(key)) {\n      this.usedTextures.set(key, []);\n    }\n\n    this.numBytesUsed += byteSize;\n    this.numUsedTextures++;\n\n    if (this.freeTextures.get(key).length > 0) {\n      this.numFreeTextures--;\n\n      const newTexture = this.freeTextures.get(key).shift();\n      this.usedTextures.get(key).push(newTexture);\n      return newTexture;\n    }\n\n    this.numBytesAllocated += byteSize;\n\n    const newTexture = this.device.createTexture({\n      size: [width, height],\n      format,\n      usage,\n    });\n    this.usedTextures.get(key).push(newTexture);\n\n    return newTexture;\n  }\n\n  releaseTexture(texture: GPUTexture) {\n    if (this.freeTextures.size === 0) {\n      return;\n    }\n\n    const width = texture.width;\n    const height = texture.height;\n    const format = texture.format;\n    const usage = texture.usage;\n\n    const key = getTextureKey(width, height, format, usage);\n    if (!this.freeTextures.has(key)) {\n      this.freeTextures.set(key, []);\n    }\n\n    this.freeTextures.get(key).push(texture);\n    this.numFreeTextures++;\n    this.numUsedTextures--;\n\n    const textureList = this.usedTextures.get(key);\n    const textureIndex = textureList.indexOf(texture);\n    if (textureIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    textureList.splice(textureIndex, 1);\n    const bytesPerElement = getBytesPerElement(format);\n    const byteSize = width * height * bytesPerElement;\n    this.numBytesUsed -= byteSize;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    this.freeTextures.forEach((textures, key) => {\n      textures.forEach(texture => {\n        texture.destroy();\n      });\n    });\n\n    this.usedTextures.forEach((textures, key) => {\n      textures.forEach(texture => {\n        texture.destroy();\n      });\n    });\n\n    this.freeTextures = new Map();\n    this.usedTextures = new Map();\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this.numBytesUsed = 0;\n    this.numBytesAllocated = 0;\n  }\n}\n\nfunction getTextureKey(\n    width: number, height: number, format: GPUTextureFormat,\n    usage: GPUTextureUsageFlags) {\n  return `${width}_${height}_${format}_${usage}`;\n}\n\nfunction getBytesPerElement(format: GPUTextureFormat) {\n  if (format === 'rgba8unorm') {\n    return 16;\n  } else {\n    throw new Error(`${format} is not supported!`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}