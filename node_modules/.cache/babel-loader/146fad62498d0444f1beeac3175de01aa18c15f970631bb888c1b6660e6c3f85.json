{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { activationFnSnippet } from './activation_util';\nimport { matMulReadWriteFnSource } from './matmul_packed_webgpu';\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch } from './webgpu_util';\nexport function makeMatMulReduceSource(workgroupSizeX) {\n  return `\n    var<workgroup> sumValues : array<f32, ${workgroupSizeX}>;\n    ${main()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${workgroupSizeX}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${workgroupSizeX / 2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `;\n}\nexport class MatMulReduceProgram {\n  constructor(outputShape, transposeA = false, transposeB = false, bias = null, activation = null, preluActivationWeights = null) {\n    this.variableNames = ['A', 'B'];\n    this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n    this.workgroupSize = [256, 1, 1];\n    this.outputShape = outputShape;\n    this.dispatchLayout = {\n      x: [],\n      y: [1, 2],\n      z: [0]\n    };\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    const addBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    this.shaderKey = `matMulReduce_${this.activation}_${transposeA}_${transposeB}`;\n  }\n  getUserCode() {\n    const userCode = `\n      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}\n      ${matMulReadWriteFnSource(this.addBias, this.activation, this.transposeA, this.transposeB)}\n      ${makeMatMulReduceSource(this.workgroupSize[0])}\n    `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["activationFnSnippet","matMulReadWriteFnSource","getMainHeaderString","main","computeDispatch","makeMatMulReduceSource","workgroupSizeX","MatMulReduceProgram","constructor","outputShape","transposeA","transposeB","bias","activation","preluActivationWeights","variableNames","uniforms","workgroupSize","dispatchLayout","x","y","z","dispatch","addBias","hasPreluActivationWeights","push","shaderKey","getUserCode","userCode"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/matmul_reduce_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {activationFnSnippet} from './activation_util';\nimport {matMulReadWriteFnSource} from './matmul_packed_webgpu';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch} from './webgpu_util';\n\nexport function makeMatMulReduceSource(workgroupSizeX: number): string {\n  return `\n    var<workgroup> sumValues : array<f32, ${workgroupSizeX}>;\n    ${main()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${workgroupSizeX}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${workgroupSizeX / 2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `;\n}\n\nexport class MatMulReduceProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n  workgroupSize: [number, number, number] = [256, 1, 1];\n  transposeA: boolean;\n  transposeB: boolean;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n\n  constructor(\n      outputShape: [number, number, number], transposeA = false,\n      transposeB = false, bias: TensorInfo = null,\n      activation: backend_util.Activation = null,\n      preluActivationWeights: TensorInfo = null) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = {x: [], y: [1, 2], z: [0]};\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    const addBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    this.shaderKey =\n        `matMulReduce_${this.activation}_${transposeA}_${transposeB}`;\n  }\n\n  getUserCode(): string {\n    const userCode = `\n      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}\n      ${\n        matMulReadWriteFnSource(\n            this.addBias, this.activation, this.transposeA, this.transposeB)}\n      ${makeMatMulReduceSource(this.workgroupSize[0])}\n    `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAmBA,SAAQA,mBAAmB,QAAO,mBAAmB;AACrD,SAAQC,uBAAuB,QAAO,wBAAwB;AAC9D,SAAQC,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AAC3E,SAAQC,eAAe,QAAO,eAAe;AAE7C,OAAM,SAAUC,sBAAsBA,CAACC,cAAsB;EAC3D,OAAO;4CACmCA,cAAc;MACpDH,IAAI,EAAE;;;;;;;;;yDAS6CG,cAAc;;;;;;;;8BAQzCA,cAAc,GAAG,CAAC;;;;;;;;;;;;;;GAc7C;AACH;AAEA,OAAM,MAAOC,mBAAmB;EAc9BC,YACIC,WAAqC,EAAEC,UAAU,GAAG,KAAK,EACzDC,UAAU,GAAG,KAAK,EAAEC,IAAA,GAAmB,IAAI,EAC3CC,UAAA,GAAsC,IAAI,EAC1CC,sBAAA,GAAqC,IAAI;IAb7C,KAAAC,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;IAC1B,KAAAC,QAAQ,GAAG,mDAAmD;IAC9D,KAAAC,aAAa,GAA6B,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;IAYnD,IAAI,CAACR,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACS,cAAc,GAAG;MAACC,CAAC,EAAE,EAAE;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC;IAAC,CAAC;IAChD,IAAI,CAACC,QAAQ,GAAGlB,eAAe,CAC3B,IAAI,CAACc,cAAc,EAAE,IAAI,CAACT,WAAW,EAAE,IAAI,CAACQ,aAAa,CAAC;IAE9D,MAAMM,OAAO,GAAGX,IAAI,IAAI,IAAI;IAC5B,MAAMY,yBAAyB,GAAGV,sBAAsB,IAAI,IAAI;IAChE,IAAIS,OAAO,EAAE;MACX,IAAI,CAACR,aAAa,CAACU,IAAI,CAAC,MAAM,CAAC;;IAGjC,IAAID,yBAAyB,EAAE;MAC7B,IAAI,CAACT,aAAa,CAACU,IAAI,CAAC,wBAAwB,CAAC;;IAGnD,IAAI,CAACf,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACY,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACV,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACW,yBAAyB,GAAGA,yBAAyB;IAC1D,IAAI,CAACE,SAAS,GACV,gBAAgB,IAAI,CAACb,UAAU,IAAIH,UAAU,IAAIC,UAAU,EAAE;EACnE;EAEAgB,WAAWA,CAAA;IACT,MAAMC,QAAQ,GAAG;QACb5B,mBAAmB,CAAC,IAAI,CAACa,UAAU,EAAE,IAAI,CAACW,yBAAyB,CAAC;QAEpEvB,uBAAuB,CACnB,IAAI,CAACsB,OAAO,EAAE,IAAI,CAACV,UAAU,EAAE,IAAI,CAACH,UAAU,EAAE,IAAI,CAACC,UAAU,CAAC;QACpEN,sBAAsB,CAAC,IAAI,CAACY,aAAa,CAAC,CAAC,CAAC,CAAC;KAChD;IACD,OAAOW,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}