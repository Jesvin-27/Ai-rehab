{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport { symbolicallyComputeStrides } from './shader_util';\nexport var PixelsOpType;\n(function (PixelsOpType) {\n  PixelsOpType[PixelsOpType[\"FROM_PIXELS\"] = 0] = \"FROM_PIXELS\";\n  PixelsOpType[PixelsOpType[\"DRAW\"] = 1] = \"DRAW\";\n})(PixelsOpType || (PixelsOpType = {}));\nexport const compileProgram = (device, program, inputsData, output, parallelCompilation) => {\n  const outputData = {\n    dtype: output.dtype,\n    shape: output.shape\n  };\n  const source = makeShader(inputsData, outputData, program);\n  const module = device.createShaderModule({\n    code: source,\n    label: program.constructor.name\n  });\n  let printShaderString = env().get('WEBGPU_PRINT_SHADER');\n  if (printShaderString !== '') {\n    printShaderString = printShaderString.toLowerCase();\n    const printShaderArray = printShaderString.split(',');\n    if (printShaderString === 'all' || printShaderArray.some(item => program.shaderKey.toLowerCase().includes(item))) {\n      console.group(program.shaderKey);\n      console.debug(source);\n      console.groupEnd();\n    }\n  }\n  if (parallelCompilation) {\n    return device.createComputePipelineAsync({\n      compute: {\n        module,\n        entryPoint: '_start'\n      },\n      label: program.constructor.name,\n      layout: 'auto'\n    });\n  } else {\n    return device.createComputePipeline({\n      compute: {\n        module,\n        entryPoint: '_start'\n      },\n      label: program.constructor.name,\n      layout: 'auto'\n    });\n  }\n};\nexport const typeSnippet = (component, type = 'f32') => {\n  switch (component) {\n    case 1:\n      return `${type}`;\n    case 2:\n      return `vec2<${type}>`;\n    case 3:\n      return `vec3<${type}>`;\n    case 4:\n      return `vec4<${type}>`;\n    default:\n      throw new Error(`${component}-component ${type} is not supported.`);\n  }\n};\nexport function getCoordsDataType(rank) {\n  if (rank <= 1) {\n    return 'i32';\n  } else if (rank === 2) {\n    return `vec2<i32>`;\n  } else if (rank === 3) {\n    return `vec3<i32>`;\n  } else if (rank === 4) {\n    return `vec4<i32>`;\n  } else if (rank === 5) {\n    return `vec5`;\n  } else if (rank === 6) {\n    return `vec6`;\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\nexport function getCoordsXYZ(index) {\n  if (index === 0) {\n    return 'x';\n  } else if (index === 1) {\n    return 'y';\n  } else if (index === 2) {\n    return 'z';\n  } else if (index === 3) {\n    return 'w';\n  } else if (index === 4) {\n    return 'u';\n  } else if (index === 5) {\n    return 'v';\n  } else {\n    throw Error(`Index ${index} is not yet supported`);\n  }\n}\nexport function getMainHeaderString(...params) {\n  let snippet;\n  switch (params.length) {\n    case 0:\n      snippet = `\n        fn main()\n      `;\n      break;\n    case 1:\n      snippet = `\n        fn main(${params[0]} : i32)\n      `;\n      break;\n    default:\n      throw Error('Unreachable');\n  }\n  return snippet;\n}\nexport function getStartHeaderString(useGlobalIndex, program) {\n  let snippet;\n  snippet = `\n     ${getWorkgroupSizeString(program)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${useGlobalIndex ? `main(getGlobalIndex());` : `main();`};\n      }\n    `;\n  return snippet;\n}\nexport function getWorkgroupSizeString(program) {\n  return `\n  @compute @workgroup_size(${program.workgroupSize[0]}, ${program.workgroupSize[1]}, ${program.workgroupSize[2]})\n`;\n}\nfunction makeShader(inputInfo, outputData, program) {\n  const prefixSnippets = [];\n  const flatWorkgroupSize = program.workgroupSize[0] * program.workgroupSize[1] * program.workgroupSize[2];\n  program.outputComponent = program.outputComponent ? program.outputComponent : 1;\n  prefixSnippets.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${isFlatDispatch(program) ? `  return i32(globalId.x);` : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${flatWorkgroupSize}u +\n                localIndex);\n        `}\n      }\n    `);\n  if (program.pixelsOpType != null) {\n    const inoutSnippet = program.pixelsOpType === PixelsOpType.FROM_PIXELS ? `@group(0) @binding(0) var<storage, read_write> result: array<${dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;` : `@group(0) @binding(1) var<storage, read> inBuf : array<${dataTypeToGPUType(inputInfo[0].dtype, program.outputComponent)}>;`;\n    const outShapeStridesType = outputData.shape.length === 3 ? 'vec2<i32>' : 'i32';\n    prefixSnippets.push(`\n        struct Uniform {\n          outShapeStrides : ${outShapeStridesType},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${inoutSnippet}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);\n    const useGlobalIndex = isFlatDispatchLayout(program);\n    return [commonSnippet, prefixSnippets.join('\\n'), getCoordsFromIndexSnippet(outputData.shape), program.getUserCode(), getStartHeaderString(useGlobalIndex, program)].join('\\n');\n  }\n  let stridesLength;\n  let stridesDataType;\n  let uniformDeclaration = 'struct Uniforms { NAN : f32, INFINITY : f32, ';\n  program.variableNames.forEach((x, i) => {\n    const perDataType = getCoordsDataType(inputInfo[i].shape.length);\n    uniformDeclaration += `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${perDataType}, `;\n    stridesLength = inputInfo[i].shape.length - 1;\n    stridesDataType = getCoordsDataType(stridesLength);\n    uniformDeclaration += `${x.charAt(0).toLowerCase() + x.slice(1)}ShapeStrides: ${stridesDataType}, `;\n  });\n  const outputDataType = getCoordsDataType(outputData.shape.length);\n  uniformDeclaration += `outShape : ${outputDataType}, `;\n  stridesLength = outputData.shape.length - 1;\n  stridesDataType = getCoordsDataType(stridesLength);\n  uniformDeclaration += `\n         outShapeStrides: ${stridesDataType}, `;\n  if (program.size) {\n    uniformDeclaration += 'size : i32, ';\n  }\n  if (program.uniforms) {\n    uniformDeclaration += program.uniforms;\n  }\n  uniformDeclaration += '};';\n  uniformDeclaration = insertAlignment(uniformDeclaration);\n  prefixSnippets.push(uniformDeclaration);\n  // Output buffer.\n  if (program.atomic) {\n    prefixSnippets.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    `);\n  } else {\n    prefixSnippets.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;\n    `);\n  }\n  program.variableNames.forEach((x, i) => {\n    prefixSnippets.push(`\n      @group(0) @binding(${1 + i}) var<storage, read> ${x}: array<${program.variableComponents ? dataTypeToGPUType(inputInfo[i].dtype, program.variableComponents[i]) : dataTypeToGPUType(inputInfo[i].dtype, program.outputComponent)}>;\n        `);\n  });\n  if (uniformDeclaration !== '') {\n    prefixSnippets.push(`\n      @group(0) @binding(${1 + program.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);\n  }\n  const coordsSnippet = getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);\n  const sources = [commonSnippet, prefixSnippets.join('\\n') + isInfSnippet, getCoordsFromIndexSnippet(outputData.shape), coordsSnippet, getOutputIndexFromCoordsSnippet(outputData.shape.length)];\n  if (!program.atomic) {\n    sources.push(setOutputSnippet(outputData.shape, outputData.dtype, program.outputComponent));\n  }\n  program.variableNames.forEach((x, i) => {\n    sources.push(`${getCoordsFromIndexSnippet(inputInfo[i].shape, x)}`);\n  });\n  const inputSnippet = inputInfo.map((x, i) => getInputSnippet(x, outputData.shape, program.variableComponents ? program.variableComponents[i] : program.outputComponent, program.dispatchLayout.x.length === outputData.shape.length)).join('\\n');\n  sources.push(inputSnippet);\n  sources.push(program.getUserCode());\n  const useGlobalIndex = isFlatDispatchLayout(program);\n  sources.push(getStartHeaderString(useGlobalIndex, program));\n  const source = sources.join('\\n');\n  return source;\n}\nexport function makeShaderKey(program, inputsData, output) {\n  let key = program.shaderKey;\n  if (program.pixelsOpType != null) {\n    return key;\n  }\n  const shapes = [];\n  const types = [];\n  inputsData.forEach(element => {\n    shapes.push(element.shape);\n    types.push(element.dtype);\n  });\n  shapes.push(output.shape);\n  types.push(output.dtype);\n  const broadcastDims = inputsData.map(d => backend_util.getBroadcastDims(d.shape, output.shape));\n  const inputShapesEqualsOutShape = inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');\n  const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');\n  const flatDispatchString = isFlatDispatch(program) ? 'flatDispatch' : '';\n  key += '_' + (program.workgroupSize ? program.workgroupSize.join(',') : '') + shapes.map(shape => shape.length).join(',') + types.join(',') + program.variableNames.join(',') + broadcastDimsKey + inputShapesEqualsOutShape + flatDispatchString;\n  return key;\n}\nconst commonSnippet = `\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n`;\nconst isInfSnippet = `\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n`;\n/**\n * Derives logical coordinates from a flat index. Performs integer division\n * with each stride and decrements the index until the index equals the final\n * dimension coordinate.\n */\nexport function getCoordsFromIndexSnippet(shape, name = '') {\n  const rank = shape.length;\n  const funcName = name !== '' ? `get${name.charAt(0).toUpperCase() + name.slice(1)}CoordsFromIndex` : 'getCoordsFromIndex';\n  const stridesName = name !== '' ? `${name.charAt(0).toLowerCase() + name.slice(1)}ShapeStrides` : `outShapeStrides`;\n  if (rank <= 1) {\n    return `fn ${funcName}(index : i32) -> i32 { return index; }`;\n  }\n  const strides = util.computeStrides(shape);\n  const dtype = getCoordsDataType(rank);\n  const coords = [];\n  for (let i = 0; i < rank; i++) {\n    coords.push(`d${i}`);\n  }\n  if (strides.length === 1) {\n    return `    fn ${funcName}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${stridesName}; let d1 = index - d0 * uniforms.${stridesName};\n      return vec2<i32>(d0, d1);\n    }`;\n  }\n  let snippet;\n  snippet = 'var index2 = index;' + strides.map((_, i) => {\n    const line1 = `let ${coords[i]} = index2 / uniforms.${stridesName}.${getCoordsXYZ(i)}`;\n    const line2 = i === strides.length - 1 ? `let ${coords[i + 1]} = index2 - ${coords[i]} * uniforms.${stridesName}.${getCoordsXYZ(i)}` : `index2 = index2 - ${coords[i]} * uniforms.${stridesName}.${getCoordsXYZ(i)}`;\n    return `${line1}; ${line2};`;\n  }).join('');\n  return `\n    fn ${funcName}(index : i32) -> ${dtype} {\n      ${snippet}\n      return ${dtype}(${coords.join(',')});\n    }\n  `;\n}\nfunction getInputAtCoordsSnippet(inputInfo, component) {\n  const texName = inputInfo.name;\n  const rank = inputInfo.shape.length;\n  const type = getCoordsDataType(rank);\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, rank);\n  const inputs = dims.map(d => `${d} : i32`).join(', ');\n  if (rank < 1) {\n    return `\n      fn ${funcName}() -> ${typeSnippet(component)} {\n        return ${typeSnippet(component)}(${texName}[0]);\n      }\n    `;\n  }\n  const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  let rankStr = `${rank}D`;\n  if (rank === 0) {\n    rankStr = '1D';\n  }\n  return `\n    fn ${funcName}(${inputs}) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${type}(${dims.join(',')}),\n        ${shapeStr})${component === 1 ? '' : ` / ${component}`}]);\n    }\n   `;\n}\nfunction getInputByOutputSnippet(inputInfo, outShape, component, isFlatDispatchLayout) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'ByOutput';\n  const inRank = inputInfo.shape.length;\n  const outRank = outShape.length;\n  const type = getCoordsDataType(outRank);\n  // If the inShape equals the outShape and the dispatch layout is flat, we can\n  // directly use |gl_GlobalInvocationID.x| as the index and don't need coords\n  // conversion between these two shapes.\n  if (util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {\n    return `\n    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[globalIndex]);\n    }\n\n    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[${outRank > 1 ? 'getOutputIndexFromCoords(coords)' : 'coords'}${component === 1 ? '' : ` / ${component}`}]);\n    }\n    `;\n  }\n  const broadcastDims = backend_util.getBroadcastDims(inputInfo.shape, outShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet = '';\n  if (inRank === 0) {\n    return `\n    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)}{\n      return get${texFuncSnippet}();\n    }\n\n    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)}{\n      return get${texFuncSnippet}();\n    }\n  `;\n  } else {\n    if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map(d => `coords.${getCoordsXYZ(d + rankDiff)} = 0;`).join('\\n');\n    }\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    if (outRank > 1) {\n      const coordsType = getCoordsDataType(inRank);\n      const coordsValues = inputInfo.shape.map((s, i) => `coords.${getCoordsXYZ(i + rankDiff)}`).join(', ');\n      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;\n    } else {\n      unpackedCoordsSnippet = 'coords';\n    }\n  }\n  const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  const rankStr = `${inRank}D`;\n  return `\n  fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${coordsSnippet}\n    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})${component === 1 ? '' : ` / ${component}`}]);\n  }\n\n  fn ${funcName}Coords(coordsIn : ${type}) -> ${typeSnippet(component)} {\n    var coords = coordsIn;\n    ${coordsSnippet}\n    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})${component === 1 ? '' : ` / ${component}`}]);\n  }\n`;\n}\nfunction getInputSnippet(inputInfo, outShape, component, isFlatDispatchLayout) {\n  let res = getInputAtCoordsSnippet(inputInfo, component);\n  const inShape = inputInfo.shape;\n  if (inShape.length <= outShape.length) {\n    res += getInputByOutputSnippet(inputInfo, outShape, component, isFlatDispatchLayout);\n  }\n  return res;\n}\n/**\n * Generates getOutputCoords() function that computes output coordinates\n * from dispatch geometry to reduce arithmetic.\n */\nfunction getOutputCoordsSnippet(outShape, dispatchLayout) {\n  const {\n    x,\n    y = [],\n    z = []\n  } = dispatchLayout;\n  const outRank = outShape.length;\n  const rank = x.length + y.length + z.length;\n  // getOutputCoords is only meaningful when the output rank is same with\n  // dispatch layout rank.\n  if (rank !== outRank) {\n    return '';\n  }\n  if (x.length === outRank) {\n    const dtype = getCoordsDataType(outRank);\n    const snippet = `fn getOutputCoords() -> ${dtype}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;\n    return snippet;\n  }\n  let gatherDimensionsStr = '';\n  const dims = [x, y, z];\n  for (let i = 0; i < dims.length; i++) {\n    const arr = dims[i];\n    if (arr.length === 0) {\n      continue;\n    }\n    if (arr.length === 1) {\n      gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i}]);`;\n    } else {\n      const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');\n      gatherDimensionsStr += `var index${i} = i32(globalId[${i}]);`;\n      for (let j = 0; j < strides.length; j++) {\n        gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;\n        if (j === strides.length - 1) {\n          gatherDimensionsStr += `let d${arr[j + 1]} = ` + `index${i} - d${arr[j]} * ${strides[j]};`;\n        } else {\n          gatherDimensionsStr += `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;\n        }\n      }\n    }\n  }\n  const dimensions = [];\n  for (let i = 0; i < rank; i++) {\n    dimensions.push(`d${i}`);\n  }\n  const dtype = getCoordsDataType(rank);\n  let snippet = `fn getOutputCoords() -> ${dtype} {\n  ${gatherDimensionsStr}\n`;\n  if (dimensions.length === 0) {\n    snippet += `return ${dtype}(0); }`;\n  } else {\n    snippet += `return ${dtype}(${dimensions.join(',')}); }`;\n  }\n  return snippet;\n}\nfunction getOutputIndexFromCoordsSnippet(outRank) {\n  let snippet = '';\n  switch (outRank) {\n    case 0:\n    case 1:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        `;\n      break;\n    case 2:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        `;\n      break;\n    case 3:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        `;\n      break;\n    case 4:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        `;\n      break;\n    case 5:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        `;\n      break;\n    case 6:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        `;\n      break;\n    default:\n      util.assert(false, () => `Unsupported ${outRank}D shape`);\n      break;\n  }\n  return snippet;\n}\nfunction isFlatDispatch(program) {\n  return program.dispatch[1] === 1 && program.dispatch[2] === 1;\n}\nexport function dataTypeToGPUType(type, component = 1) {\n  if (type === 'float32') {\n    return typeSnippet(component, 'f32');\n  } else if (type === 'int32' || type === 'bool') {\n    return typeSnippet(component, 'i32');\n  }\n  throw new Error(`type ${type} is not supported.`);\n}\nfunction setOutputSnippet(outShape, outBufferType, component) {\n  const outRank = outShape.length;\n  const gpuType = dataTypeToGPUType(outBufferType, component);\n  let snippet = `fn setOutputAtIndex(flatIndex : i32, value : ${typeSnippet(component)}) {\n      result[flatIndex] = ${gpuType}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${typeSnippet(component, 'i32')}) {\n      result[flatIndex] = ${gpuType}(value);\n    }\n    `;\n  if (outRank >= 2) {\n    const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, outRank);\n    const type = getCoordsDataType(outRank);\n    snippet += `\n      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : ${typeSnippet(component)}) {\n        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));\n        setOutputAtIndex(flatIndex${component === 1 ? '' : ` / ${component}`}, value);\n      }\n      fn setOutputAtCoordsI32(${dims.map(d => `${d} : i32`).join(', ')}, value : ${typeSnippet(component, 'i32')}) {\n        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));\n        setOutputAtIndexI32(flatIndex${component === 1 ? '' : ` / ${component}`}, value);\n      }\n    `;\n  }\n  return snippet;\n}\nfunction insertAlignment(uniformShader) {\n  // insert alignment when current pattern is vec5 or vec6\n  const curInsertRe = /(\\w+)\\s*:\\s*vec(5|6)/g;\n  uniformShader = uniformShader.replace(curInsertRe, match => {\n    return '@align(16) ' + match;\n  });\n  // insert alignment when previous pattern is vec5 or vec6\n  const preInsertRe = /vec(5|6)\\s*,\\s*(\\w+)/g;\n  uniformShader = uniformShader.replace(preInsertRe, (_, p1, p2) => {\n    return `vec${p1}, @align(16) ${p2}`;\n  });\n  return uniformShader;\n}\nfunction isFlatDispatchLayout(program) {\n  if (program.dispatchLayout.hasOwnProperty('y') && program.dispatchLayout.y.length !== 0) {\n    return false;\n  }\n  if (program.dispatchLayout.hasOwnProperty('z') && program.dispatchLayout.z.length !== 0) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["backend_util","env","util","symbolicallyComputeStrides","PixelsOpType","compileProgram","device","program","inputsData","output","parallelCompilation","outputData","dtype","shape","source","makeShader","module","createShaderModule","code","label","constructor","name","printShaderString","get","toLowerCase","printShaderArray","split","some","item","shaderKey","includes","console","group","debug","groupEnd","createComputePipelineAsync","compute","entryPoint","layout","createComputePipeline","typeSnippet","component","type","Error","getCoordsDataType","rank","getCoordsXYZ","index","getMainHeaderString","params","snippet","length","getStartHeaderString","useGlobalIndex","getWorkgroupSizeString","workgroupSize","inputInfo","prefixSnippets","flatWorkgroupSize","outputComponent","push","isFlatDispatch","pixelsOpType","inoutSnippet","FROM_PIXELS","dataTypeToGPUType","outShapeStridesType","isFlatDispatchLayout","commonSnippet","join","getCoordsFromIndexSnippet","getUserCode","stridesLength","stridesDataType","uniformDeclaration","variableNames","forEach","x","i","perDataType","charAt","slice","outputDataType","size","uniforms","insertAlignment","atomic","variableComponents","coordsSnippet","getOutputCoordsSnippet","dispatchLayout","sources","isInfSnippet","getOutputIndexFromCoordsSnippet","setOutputSnippet","inputSnippet","map","getInputSnippet","makeShaderKey","key","shapes","types","element","broadcastDims","d","getBroadcastDims","inputShapesEqualsOutShape","arraysEqual","broadcastDimsKey","flatDispatchString","funcName","toUpperCase","stridesName","strides","computeStrides","coords","_","line1","line2","getInputAtCoordsSnippet","texName","dims","inputs","shapeStr","rankStr","getInputByOutputSnippet","outShape","texFuncSnippet","inRank","outRank","rankDiff","unpackedCoordsSnippet","coordsType","coordsValues","s","res","inShape","y","z","gatherDimensionsStr","arr","j","dimensions","assert","dispatch","outBufferType","gpuType","uniformShader","curInsertRe","replace","match","preInsertRe","p1","p2","hasOwnProperty"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/webgpu_program.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, DataTypeMap, env, Rank, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {symbolicallyComputeStrides} from './shader_util';\n\nexport enum PixelsOpType {\n  FROM_PIXELS,\n  DRAW\n}\n\nexport interface WebGPUProgram {\n  // Whether to use atomic built-in functions.\n  atomic?: boolean;\n  // dispatch specifies geometry of thread groups - derived from dispatchLayout.\n  dispatch: [number, number, number];\n  // dispatchLayout enumerates how tensor dimensions are distributed among\n  // dispatch x,y,z dimensions.\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  // By default, the output data component is 1.\n  outputComponent?: number;\n  outputShape: number[];\n  pixelsOpType?: PixelsOpType;\n  // The unique key to distinguish different shader source code.\n  shaderKey: string;\n  // Whether to use output size for bounds checking.\n  size?: boolean;\n  uniforms?: string;\n  variableNames: string[];\n  // Describe each variable's component and must have one-one mapping with\n  // variableNames. If not set, all variables component will be same with output\n  // component member.\n  variableComponents?: number[];\n  // workgroupSize.x * workgroupSize.y * workgroupSize.z = the number of threads\n  // in a thread group. Individual dimensions determines thread layout within\n  // the group.\n  workgroupSize: [number, number, number];\n  // Size of register cache in one dimension (assumes square cache).\n  // Each thread writes to workPerThread * workPerThread locations in the output\n  // buffer.\n  workPerThread?: number;\n  pipeline?: GPUComputePipeline|Promise<GPUComputePipeline>;\n  getUserCode: () => string;\n}\n\nexport const compileProgram =\n    (device: GPUDevice, program: WebGPUProgram, inputsData: InputInfo[],\n     output: TensorInfo, parallelCompilation: boolean): GPUComputePipeline|\n    Promise<GPUComputePipeline> => {\n      const outputData = {dtype: output.dtype, shape: output.shape};\n      const source = makeShader(inputsData, outputData, program);\n      const module = device.createShaderModule(\n          {code: source, label: program.constructor.name});\n\n      let printShaderString = env().get('WEBGPU_PRINT_SHADER') as string;\n      if (printShaderString !== '') {\n        printShaderString = printShaderString.toLowerCase();\n        const printShaderArray = printShaderString.split(',');\n        if (printShaderString === 'all' ||\n            printShaderArray.some(\n                item => program.shaderKey.toLowerCase().includes(item))) {\n          console.group(program.shaderKey);\n          console.debug(source);\n          console.groupEnd();\n        }\n      }\n\n      if (parallelCompilation) {\n        return device.createComputePipelineAsync({\n          compute: {module, entryPoint: '_start'},\n          label: program.constructor.name,\n          layout: 'auto'\n        });\n      } else {\n        return device.createComputePipeline({\n          compute: {module, entryPoint: '_start'},\n          label: program.constructor.name,\n          layout: 'auto'\n        });\n      }\n    };\n\nexport const typeSnippet = (component: number, type = 'f32') => {\n  switch (component) {\n    case 1:\n      return `${type}`;\n    case 2:\n      return `vec2<${type}>`;\n    case 3:\n      return `vec3<${type}>`;\n    case 4:\n      return `vec4<${type}>`;\n    default:\n      throw new Error(`${component}-component ${type} is not supported.`);\n  }\n};\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'i32';\n  } else if (rank === 2) {\n    return `vec2<i32>`;\n  } else if (rank === 3) {\n    return `vec3<i32>`;\n  } else if (rank === 4) {\n    return `vec4<i32>`;\n  } else if (rank === 5) {\n    return `vec5`;\n  } else if (rank === 6) {\n    return `vec6`;\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getCoordsXYZ(index: number): string {\n  if (index === 0) {\n    return 'x';\n  } else if (index === 1) {\n    return 'y';\n  } else if (index === 2) {\n    return 'z';\n  } else if (index === 3) {\n    return 'w';\n  } else if (index === 4) {\n    return 'u';\n  } else if (index === 5) {\n    return 'v';\n  } else {\n    throw Error(`Index ${index} is not yet supported`);\n  }\n}\n\nexport function getMainHeaderString(): string;\nexport function getMainHeaderString(index: string): string;\nexport function getMainHeaderString(...params: string[]): string {\n  let snippet: string;\n  switch (params.length) {\n    case 0:\n      snippet = `\n        fn main()\n      `;\n      break;\n    case 1:\n      snippet = `\n        fn main(${params[0]} : i32)\n      `;\n      break;\n    default:\n      throw Error('Unreachable');\n  }\n  return snippet;\n}\n\nexport function getStartHeaderString(\n    useGlobalIndex: boolean, program: WebGPUProgram): string {\n  let snippet: string;\n  snippet = `\n     ${getWorkgroupSizeString(program)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${useGlobalIndex ? `main(getGlobalIndex());` : `main();`};\n      }\n    `;\n  return snippet;\n}\n\nexport function getWorkgroupSizeString(program: WebGPUProgram): string {\n  return `\n  @compute @workgroup_size(${program.workgroupSize[0]}, ${\n      program.workgroupSize[1]}, ${program.workgroupSize[2]})\n`;\n}\n\nfunction makeShader(\n    inputInfo: InputInfo[], outputData: {dtype: DataType, shape: number[]},\n    program: WebGPUProgram): string {\n  const prefixSnippets: string[] = [];\n  const flatWorkgroupSize = program.workgroupSize[0] *\n      program.workgroupSize[1] * program.workgroupSize[2];\n  program.outputComponent =\n      program.outputComponent ? program.outputComponent : 1;\n  prefixSnippets.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${\n      isFlatDispatch(program) ?\n          `  return i32(globalId.x);` :\n          `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${\n              flatWorkgroupSize}u +\n                localIndex);\n        `}\n      }\n    `);\n\n  if (program.pixelsOpType != null) {\n    const inoutSnippet = program.pixelsOpType === PixelsOpType.FROM_PIXELS ?\n        `@group(0) @binding(0) var<storage, read_write> result: array<${\n            dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;` :\n        `@group(0) @binding(1) var<storage, read> inBuf : array<${\n            dataTypeToGPUType(inputInfo[0].dtype, program.outputComponent)}>;`;\n    const outShapeStridesType =\n        outputData.shape.length === 3 ? 'vec2<i32>' : 'i32';\n    prefixSnippets.push(`\n        struct Uniform {\n          outShapeStrides : ${outShapeStridesType},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${inoutSnippet}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);\n    const useGlobalIndex = isFlatDispatchLayout(program);\n    return [\n      commonSnippet,\n      prefixSnippets.join('\\n'),\n      getCoordsFromIndexSnippet(outputData.shape),\n      program.getUserCode(),\n      getStartHeaderString(useGlobalIndex, program),\n    ].join('\\n');\n  }\n\n  let stridesLength: number;\n  let stridesDataType: string;\n  let uniformDeclaration = 'struct Uniforms { NAN : f32, INFINITY : f32, ';\n  program.variableNames.forEach((x, i) => {\n    const perDataType = getCoordsDataType(inputInfo[i].shape.length);\n    uniformDeclaration +=\n        `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${perDataType}, `;\n    stridesLength = inputInfo[i].shape.length - 1;\n    stridesDataType = getCoordsDataType(stridesLength);\n    uniformDeclaration +=\n        `${x.charAt(0).toLowerCase() + x.slice(1)}ShapeStrides: ${\n            stridesDataType}, `;\n  });\n  const outputDataType = getCoordsDataType(outputData.shape.length);\n  uniformDeclaration += `outShape : ${outputDataType}, `;\n  stridesLength = outputData.shape.length - 1;\n  stridesDataType = getCoordsDataType(stridesLength);\n  uniformDeclaration += `\n         outShapeStrides: ${stridesDataType}, `;\n\n  if (program.size) {\n    uniformDeclaration += 'size : i32, ';\n  }\n\n  if (program.uniforms) {\n    uniformDeclaration += program.uniforms;\n  }\n  uniformDeclaration += '};';\n  uniformDeclaration = insertAlignment(uniformDeclaration);\n\n  prefixSnippets.push(uniformDeclaration);\n\n  // Output buffer.\n  if (program.atomic) {\n    prefixSnippets.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    `);\n  } else {\n    prefixSnippets.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${\n        dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;\n    `);\n  }\n  program.variableNames.forEach((x, i) => {\n    prefixSnippets.push(`\n      @group(0) @binding(${1 + i}) var<storage, read> ${x}: array<${\n        program.variableComponents ?\n            dataTypeToGPUType(\n                inputInfo[i].dtype, program.variableComponents[i]) :\n            dataTypeToGPUType(inputInfo[i].dtype, program.outputComponent)}>;\n        `);\n  });\n\n  if (uniformDeclaration !== '') {\n    prefixSnippets.push(`\n      @group(0) @binding(${\n        1 + program.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);\n  }\n\n  const coordsSnippet =\n      getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);\n\n  const sources = [\n    commonSnippet, prefixSnippets.join('\\n') + isInfSnippet,\n    getCoordsFromIndexSnippet(outputData.shape), coordsSnippet,\n    getOutputIndexFromCoordsSnippet(outputData.shape.length)\n  ];\n  if (!program.atomic) {\n    sources.push(setOutputSnippet(\n        outputData.shape, outputData.dtype, program.outputComponent));\n  }\n\n  program.variableNames.forEach((x, i) => {\n    sources.push(`${getCoordsFromIndexSnippet(inputInfo[i].shape, x)}`);\n  });\n\n  const inputSnippet =\n      inputInfo\n          .map(\n              (x, i) => getInputSnippet(\n                  x, outputData.shape,\n                  program.variableComponents ? program.variableComponents[i] :\n                                               program.outputComponent,\n                  program.dispatchLayout.x.length === outputData.shape.length))\n          .join('\\n');\n  sources.push(inputSnippet);\n  sources.push(program.getUserCode());\n  const useGlobalIndex = isFlatDispatchLayout(program);\n  sources.push(getStartHeaderString(useGlobalIndex, program));\n  const source = sources.join('\\n');\n  return source;\n}\n\nexport function makeShaderKey<R extends Rank>(\n    program: WebGPUProgram, inputsData: InputInfo[],\n    output: TensorInfo): string {\n  let key = program.shaderKey;\n  if (program.pixelsOpType != null) {\n    return key;\n  }\n\n  const shapes: number[][] = [];\n  const types: Array<keyof DataTypeMap> = [];\n  inputsData.forEach(element => {\n    shapes.push(element.shape);\n    types.push(element.dtype);\n  });\n  shapes.push(output.shape);\n  types.push(output.dtype);\n\n  const broadcastDims =\n      inputsData.map(d => backend_util.getBroadcastDims(d.shape, output.shape));\n  const inputShapesEqualsOutShape =\n      inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');\n  const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');\n\n  const flatDispatchString = isFlatDispatch(program) ? 'flatDispatch' : '';\n\n  key += '_' + (program.workgroupSize ? program.workgroupSize.join(',') : '') +\n      shapes.map(shape => shape.length).join(',') + types.join(',') +\n      program.variableNames.join(',') + broadcastDimsKey +\n      inputShapesEqualsOutShape + flatDispatchString;\n\n  return key;\n}\n\nconst commonSnippet = `\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n`;\n\nconst isInfSnippet = `\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n`;\n\ntype InputInfo = {\n  dtype: DataType; shape: number[]; name: string;\n};\n\n/**\n * Derives logical coordinates from a flat index. Performs integer division\n * with each stride and decrements the index until the index equals the final\n * dimension coordinate.\n */\nexport function getCoordsFromIndexSnippet(shape: number[], name = ''): string {\n  const rank = shape.length;\n  const funcName = name !== '' ?\n      `get${name.charAt(0).toUpperCase() + name.slice(1)}CoordsFromIndex` :\n      'getCoordsFromIndex';\n  const stridesName = name !== '' ?\n      `${name.charAt(0).toLowerCase() + name.slice(1)}ShapeStrides` :\n      `outShapeStrides`;\n\n  if (rank <= 1) {\n    return `fn ${funcName}(index : i32) -> i32 { return index; }`;\n  }\n\n  const strides = util.computeStrides(shape);\n  const dtype = getCoordsDataType(rank);\n\n  const coords: string[] = [];\n  for (let i = 0; i < rank; i++) {\n    coords.push(`d${i}`);\n  }\n\n  if (strides.length === 1) {\n    return `    fn ${funcName}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${\n        stridesName}; let d1 = index - d0 * uniforms.${stridesName};\n      return vec2<i32>(d0, d1);\n    }`;\n  }\n  let snippet;\n  snippet = 'var index2 = index;' +\n      strides\n          .map((_, i) => {\n            const line1 = `let ${coords[i]} = index2 / uniforms.${\n                stridesName}.${getCoordsXYZ(i)}`;\n            const line2 = i === strides.length - 1 ?\n                `let ${coords[i + 1]} = index2 - ${coords[i]} * uniforms.${\n                    stridesName}.${getCoordsXYZ(i)}` :\n                `index2 = index2 - ${coords[i]} * uniforms.${stridesName}.${\n                    getCoordsXYZ(i)}`;\n            return `${line1}; ${line2};`;\n          })\n          .join('');\n\n  return `\n    fn ${funcName}(index : i32) -> ${dtype} {\n      ${snippet}\n      return ${dtype}(${coords.join(',')});\n    }\n  `;\n}\n\nfunction getInputAtCoordsSnippet(\n    inputInfo: InputInfo, component: number): string {\n  const texName = inputInfo.name;\n  const rank = inputInfo.shape.length;\n  const type = getCoordsDataType(rank);\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, rank);\n  const inputs = dims.map(d => `${d} : i32`).join(', ');\n\n  if (rank < 1) {\n    return `\n      fn ${funcName}() -> ${typeSnippet(component)} {\n        return ${typeSnippet(component)}(${texName}[0]);\n      }\n    `;\n  }\n\n  const shapeStr =\n      `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  let rankStr = `${rank}D`;\n  if (rank === 0) {\n    rankStr = '1D';\n  }\n\n  return `\n    fn ${funcName}(${inputs}) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[getIndexFromCoords${\n      rankStr}(${type}(${dims.join(',')}),\n        ${shapeStr})${component === 1 ? '' : ` / ${component}`}]);\n    }\n   `;\n}\n\nfunction getInputByOutputSnippet(\n    inputInfo: InputInfo, outShape: number[], component: number,\n    isFlatDispatchLayout: boolean): string {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const funcName = 'get' + texFuncSnippet + 'ByOutput';\n\n  const inRank = inputInfo.shape.length;\n  const outRank = outShape.length;\n  const type = getCoordsDataType(outRank);\n\n  // If the inShape equals the outShape and the dispatch layout is flat, we can\n  // directly use |gl_GlobalInvocationID.x| as the index and don't need coords\n  // conversion between these two shapes.\n  if (util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {\n    return `\n    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[globalIndex]);\n    }\n\n    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[${\n        outRank > 1 ? 'getOutputIndexFromCoords(coords)' :\n                      'coords'}${component === 1 ? '' : ` / ${component}`}]);\n    }\n    `;\n  }\n\n  const broadcastDims =\n      backend_util.getBroadcastDims(inputInfo.shape, outShape);\n  const rankDiff = outRank - inRank;\n\n  let coordsSnippet = '';\n\n  if (inRank === 0) {\n    return `\n    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)}{\n      return get${texFuncSnippet}();\n    }\n\n    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)}{\n      return get${texFuncSnippet}();\n    }\n  `;\n  } else {\n    if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet =\n          broadcastDims.map(d => `coords.${getCoordsXYZ(d + rankDiff)} = 0;`)\n              .join('\\n');\n    }\n  }\n\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    if (outRank > 1) {\n      const coordsType = getCoordsDataType(inRank);\n      const coordsValues =\n          inputInfo.shape.map((s, i) => `coords.${getCoordsXYZ(i + rankDiff)}`)\n              .join(', ');\n      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;\n    } else {\n      unpackedCoordsSnippet = 'coords';\n    }\n  }\n\n  const shapeStr =\n      `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  const rankStr = `${inRank}D`;\n\n  return `\n  fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${coordsSnippet}\n    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${\n      unpackedCoordsSnippet}, ${shapeStr})${\n      component === 1 ? '' : ` / ${component}`}]);\n  }\n\n  fn ${funcName}Coords(coordsIn : ${type}) -> ${typeSnippet(component)} {\n    var coords = coordsIn;\n    ${coordsSnippet}\n    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${\n      unpackedCoordsSnippet}, ${shapeStr})${\n      component === 1 ? '' : ` / ${component}`}]);\n  }\n`;\n}\n\nfunction getInputSnippet(\n    inputInfo: InputInfo, outShape: number[], component: number,\n    isFlatDispatchLayout: boolean): string {\n  let res = getInputAtCoordsSnippet(inputInfo, component);\n\n  const inShape = inputInfo.shape;\n  if (inShape.length <= outShape.length) {\n    res += getInputByOutputSnippet(\n        inputInfo, outShape, component, isFlatDispatchLayout);\n  }\n\n  return res;\n}\n\n/**\n * Generates getOutputCoords() function that computes output coordinates\n * from dispatch geometry to reduce arithmetic.\n */\nfunction getOutputCoordsSnippet(\n    outShape: number[],\n    dispatchLayout: {x: number[], y?: number[], z?: number[]}): string {\n  const {x, y = [], z = []} = dispatchLayout;\n\n  const outRank = outShape.length;\n  const rank = x.length + y.length + z.length;\n  // getOutputCoords is only meaningful when the output rank is same with\n  // dispatch layout rank.\n  if (rank !== outRank) {\n    return '';\n  }\n\n  if (x.length === outRank) {\n    const dtype = getCoordsDataType(outRank);\n    const snippet = `fn getOutputCoords() -> ${dtype}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;\n    return snippet;\n  }\n\n  let gatherDimensionsStr = '';\n  const dims = [x, y, z];\n\n  for (let i = 0; i < dims.length; i++) {\n    const arr = dims[i];\n\n    if (arr.length === 0) {\n      continue;\n    }\n\n    if (arr.length === 1) {\n      gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i}]);`;\n    } else {\n      const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');\n      gatherDimensionsStr += `var index${i} = i32(globalId[${i}]);`;\n      for (let j = 0; j < strides.length; j++) {\n        gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;\n\n        if (j === strides.length - 1) {\n          gatherDimensionsStr += `let d${arr[j + 1]} = ` +\n              `index${i} - d${arr[j]} * ${strides[j]};`;\n        } else {\n          gatherDimensionsStr +=\n              `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;\n        }\n      }\n    }\n  }\n\n  const dimensions = [];\n  for (let i = 0; i < rank; i++) {\n    dimensions.push(`d${i}`);\n  }\n\n  const dtype = getCoordsDataType(rank);\n  let snippet = `fn getOutputCoords() -> ${dtype} {\n  ${gatherDimensionsStr}\n`;\n  if (dimensions.length === 0) {\n    snippet += `return ${dtype}(0); }`;\n  } else {\n    snippet += `return ${dtype}(${dimensions.join(',')}); }`;\n  }\n\n  return snippet;\n}\n\nfunction getOutputIndexFromCoordsSnippet(outRank: number) {\n  let snippet = '';\n  switch (outRank) {\n    case 0:\n    case 1:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        `;\n      break;\n    case 2:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        `;\n      break;\n    case 3:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        `;\n      break;\n    case 4:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        `;\n      break;\n    case 5:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        `;\n      break;\n    case 6:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        `;\n      break;\n    default:\n      util.assert(false, () => `Unsupported ${outRank}D shape`);\n      break;\n  }\n  return snippet;\n}\n\nfunction isFlatDispatch(program: WebGPUProgram): boolean {\n  return program.dispatch[1] === 1 && program.dispatch[2] === 1;\n}\n\nexport function dataTypeToGPUType(type: DataType, component = 1) {\n  if (type === 'float32') {\n    return typeSnippet(component, 'f32');\n  } else if (type === 'int32' || type === 'bool') {\n    return typeSnippet(component, 'i32');\n  }\n  throw new Error(`type ${type} is not supported.`);\n}\n\nfunction setOutputSnippet(\n    outShape: number[], outBufferType: DataType, component: number): string {\n  const outRank = outShape.length;\n  const gpuType = dataTypeToGPUType(outBufferType, component);\n  let snippet =\n      `fn setOutputAtIndex(flatIndex : i32, value : ${typeSnippet(component)}) {\n      result[flatIndex] = ${gpuType}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${\n          typeSnippet(component, 'i32')}) {\n      result[flatIndex] = ${gpuType}(value);\n    }\n    `;\n  if (outRank >= 2) {\n    const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, outRank);\n    const type = getCoordsDataType(outRank);\n\n    snippet += `\n      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : ${\n        typeSnippet(component)}) {\n        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));\n        setOutputAtIndex(flatIndex${\n        component === 1 ? '' : ` / ${component}`}, value);\n      }\n      fn setOutputAtCoordsI32(${\n        dims.map(d => `${d} : i32`).join(', ')}, value : ${\n        typeSnippet(component, 'i32')}) {\n        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));\n        setOutputAtIndexI32(flatIndex${\n        component === 1 ? '' : ` / ${component}`}, value);\n      }\n    `;\n  }\n\n  return snippet;\n}\n\nfunction insertAlignment(uniformShader: string) {\n  // insert alignment when current pattern is vec5 or vec6\n  const curInsertRe = /(\\w+)\\s*:\\s*vec(5|6)/g;\n  uniformShader = uniformShader.replace(curInsertRe, (match) => {\n    return '@align(16) ' + match;\n  });\n\n  // insert alignment when previous pattern is vec5 or vec6\n  const preInsertRe = /vec(5|6)\\s*,\\s*(\\w+)/g;\n  uniformShader = uniformShader.replace(preInsertRe, (_, p1, p2) => {\n    return `vec${p1}, @align(16) ${p2}`;\n  });\n  return uniformShader;\n}\nfunction isFlatDispatchLayout(program: WebGPUProgram): boolean {\n  if (program.dispatchLayout.hasOwnProperty('y') &&\n      program.dispatchLayout.y.length !== 0) {\n    return false;\n  }\n  if (program.dispatchLayout.hasOwnProperty('z') &&\n      program.dispatchLayout.z.length !== 0) {\n    return false;\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}