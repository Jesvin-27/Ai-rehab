{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { activationFnSnippet, biasActivationSnippet } from './activation_util';\nimport { makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource } from './matmul_packed_webgpu';\nimport { atomicAddSnippet } from './shader_util';\nimport { getMainHeaderString as main, typeSnippet } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class MatMulSplitKProgram {\n  constructor(outputShape, dimInner, transposeA = false, transposeB = false) {\n    this.variableNames = ['A', 'B'];\n    this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n    this.workgroupSize = [8, 8, 1];\n    this.atomic = true;\n    this.splitedDimInner = 128;\n    util.assert(outputShape[0] === 1, () => 'MatMulSplitKProgram only supports batch = 1.');\n    this.outputShape = outputShape;\n    this.dispatchLayout = {\n      x: [2],\n      y: [1],\n      z: [0, 3]\n    };\n    const isVec4 = (transposeA && this.outputShape[1] % 4 === 0 || !transposeA && dimInner % 4 === 0) && this.outputShape[2] % 4 === 0;\n    this.elementsPerThread = [4, 4, this.splitedDimInner];\n    this.outputComponent = isVec4 ? 4 : 1;\n    if (!isVec4) {\n      if (this.outputShape[1] < 16) {\n        this.elementsPerThread[1] = 1;\n      }\n      if (this.outputShape[2] < 16) {\n        this.elementsPerThread[0] = 1;\n      }\n    }\n    this.dispatch = computeDispatch(this.dispatchLayout, [this.outputShape[0], this.outputShape[1], this.outputShape[2], dimInner], this.workgroupSize, this.elementsPerThread);\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.shaderKey = `matMulSplitK_${transposeA}_${transposeB}_${this.elementsPerThread}_${this.outputComponent}`;\n  }\n  getUserCode() {\n    const component = this.outputComponent;\n    const userCode = `\n      ${matMulReadFnSource(false, this.transposeB, false, false, false, component)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${typeSnippet(component)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${component}; i = i + 1) {\n            ${atomicAddSnippet('&result[flatIndex + i]', `${component > 1 ? 'value[i]' : 'value'}`, 'float32')}\n          }\n        }\n      }\n      ${component === 4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}\n    `;\n    return userCode;\n  }\n}\nexport class BiasActivationProgram {\n  constructor(outputShape, bias = null, activation = null, preluActivationWeights = null) {\n    this.uniforms = '';\n    this.variableNames = ['x'];\n    this.workgroupSize = [64, 1, 1];\n    this.size = true;\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.addBias = bias != null;\n    this.hasPreluActivationWeights = preluActivationWeights != null;\n    this.activation = activation;\n    if (this.addBias) {\n      this.variableNames.push('bias');\n    }\n    if (this.hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    this.shaderKey = `biasActivation_${activation}`;\n  }\n  getUserCode() {\n    return `\n    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${biasActivationSnippet(this.addBias, this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `;\n  }\n}","map":{"version":3,"names":["util","activationFnSnippet","biasActivationSnippet","makeMatMulPackedSource","makeMatMulPackedVec4Source","matMulReadFnSource","atomicAddSnippet","getMainHeaderString","main","typeSnippet","computeDispatch","flatDispatchLayout","MatMulSplitKProgram","constructor","outputShape","dimInner","transposeA","transposeB","variableNames","uniforms","workgroupSize","atomic","splitedDimInner","assert","dispatchLayout","x","y","z","isVec4","elementsPerThread","outputComponent","dispatch","shaderKey","getUserCode","component","userCode","BiasActivationProgram","bias","activation","preluActivationWeights","size","addBias","hasPreluActivationWeights","push"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/matmul_splitK_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {activationFnSnippet, biasActivationSnippet} from './activation_util';\nimport {makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource} from './matmul_packed_webgpu';\nimport {atomicAddSnippet} from './shader_util';\nimport {getMainHeaderString as main, typeSnippet, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class MatMulSplitKProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n  workgroupSize: [number, number, number] = [8, 8, 1];\n  elementsPerThread: [number, number, number];\n  transposeA: boolean;\n  transposeB: boolean;\n  atomic = true;\n  outputComponent: number;\n  splitedDimInner = 128;\n\n  constructor(\n      outputShape: [number, number, number], dimInner: number,\n      transposeA = false, transposeB = false) {\n    util.assert(\n        outputShape[0] === 1,\n        () => 'MatMulSplitKProgram only supports batch = 1.');\n    this.outputShape = outputShape;\n    this.dispatchLayout = {x: [2], y: [1], z: [0, 3]};\n    const isVec4 = (transposeA && this.outputShape[1] % 4 === 0 ||\n                    !transposeA && dimInner % 4 === 0) &&\n        this.outputShape[2] % 4 === 0;\n    this.elementsPerThread = [4, 4, this.splitedDimInner];\n    this.outputComponent = isVec4 ? 4 : 1;\n    if (!isVec4) {\n      if (this.outputShape[1] < 16) {\n        this.elementsPerThread[1] = 1;\n      }\n      if (this.outputShape[2] < 16) {\n        this.elementsPerThread[0] = 1;\n      }\n    }\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout,\n        [\n          this.outputShape[0], this.outputShape[1], this.outputShape[2],\n          dimInner\n        ],\n        this.workgroupSize, this.elementsPerThread);\n\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.shaderKey = `matMulSplitK_${transposeA}_${transposeB}_${\n        this.elementsPerThread}_${this.outputComponent}`;\n  }\n\n  getUserCode(): string {\n    const component = this.outputComponent;\n    const userCode = `\n      ${\n        matMulReadFnSource(\n            false, this.transposeB, false, false, false, component)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${\n        typeSnippet(component)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${component}; i = i + 1) {\n            ${\n        atomicAddSnippet(\n            '&result[flatIndex + i]', `${component > 1 ? 'value[i]' : 'value'}`,\n            'float32')}\n          }\n        }\n      }\n      ${\n        component === 4 ? makeMatMulPackedVec4Source(\n                              this.elementsPerThread, this.workgroupSize,\n                              this.transposeA, 32, true, this.splitedDimInner) :\n                          makeMatMulPackedSource(\n                              this.elementsPerThread, this.workgroupSize,\n                              this.transposeA, 32, true, this.splitedDimInner)}\n    `;\n    return userCode;\n  }\n}\n\nexport class BiasActivationProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  uniforms = '';\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  size = true;\n  private addBias: boolean;\n  private activation: backend_util.Activation;\n  private hasPreluActivationWeights: boolean;\n\n  constructor(\n      outputShape: number[], bias: TensorInfo = null,\n      activation: backend_util.Activation = null,\n      preluActivationWeights: TensorInfo = null) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.addBias = bias != null;\n    this.hasPreluActivationWeights = preluActivationWeights != null;\n    this.activation = activation;\n    if (this.addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (this.hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.shaderKey = `biasActivation_${activation}`;\n  }\n\n  getUserCode(): string {\n    return `\n    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${biasActivationSnippet(this.addBias, this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAkCA,IAAI,QAAO,uBAAuB;AAEpE,SAAQC,mBAAmB,EAAEC,qBAAqB,QAAO,mBAAmB;AAC5E,SAAQC,sBAAsB,EAAEC,0BAA0B,EAAEC,kBAAkB,QAAO,wBAAwB;AAC7G,SAAQC,gBAAgB,QAAO,eAAe;AAC9C,SAAQC,mBAAmB,IAAIC,IAAI,EAAEC,WAAW,QAAsB,kBAAkB;AACxF,SAAQC,eAAe,EAAEC,kBAAkB,QAAO,eAAe;AAEjE,OAAM,MAAOC,mBAAmB;EAe9BC,YACIC,WAAqC,EAAEC,QAAgB,EACvDC,UAAU,GAAG,KAAK,EAAEC,UAAU,GAAG,KAAK;IAZ1C,KAAAC,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;IAC1B,KAAAC,QAAQ,GAAG,mDAAmD;IAC9D,KAAAC,aAAa,GAA6B,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAInD,KAAAC,MAAM,GAAG,IAAI;IAEb,KAAAC,eAAe,GAAG,GAAG;IAKnBtB,IAAI,CAACuB,MAAM,CACPT,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,EACpB,MAAM,8CAA8C,CAAC;IACzD,IAAI,CAACA,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACU,cAAc,GAAG;MAACC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC;IACjD,MAAMC,MAAM,GAAG,CAACZ,UAAU,IAAI,IAAI,CAACF,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,IAC3C,CAACE,UAAU,IAAID,QAAQ,GAAG,CAAC,KAAK,CAAC,KAC7C,IAAI,CAACD,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC;IACjC,IAAI,CAACe,iBAAiB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACP,eAAe,CAAC;IACrD,IAAI,CAACQ,eAAe,GAAGF,MAAM,GAAG,CAAC,GAAG,CAAC;IACrC,IAAI,CAACA,MAAM,EAAE;MACX,IAAI,IAAI,CAACd,WAAW,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE;QAC5B,IAAI,CAACe,iBAAiB,CAAC,CAAC,CAAC,GAAG,CAAC;;MAE/B,IAAI,IAAI,CAACf,WAAW,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE;QAC5B,IAAI,CAACe,iBAAiB,CAAC,CAAC,CAAC,GAAG,CAAC;;;IAIjC,IAAI,CAACE,QAAQ,GAAGrB,eAAe,CAC3B,IAAI,CAACc,cAAc,EACnB,CACE,IAAI,CAACV,WAAW,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,WAAW,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,WAAW,CAAC,CAAC,CAAC,EAC7DC,QAAQ,CACT,EACD,IAAI,CAACK,aAAa,EAAE,IAAI,CAACS,iBAAiB,CAAC;IAE/C,IAAI,CAACb,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACe,SAAS,GAAG,gBAAgBhB,UAAU,IAAIC,UAAU,IACrD,IAAI,CAACY,iBAAiB,IAAI,IAAI,CAACC,eAAe,EAAE;EACtD;EAEAG,WAAWA,CAAA;IACT,MAAMC,SAAS,GAAG,IAAI,CAACJ,eAAe;IACtC,MAAMK,QAAQ,GAAG;QAEb9B,kBAAkB,CACd,KAAK,EAAE,IAAI,CAACY,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAEiB,SAAS,CAAC;8DAE3DzB,WAAW,CAACyB,SAAS,CAAC;;;;;;gCAMEA,SAAS;cAEjC5B,gBAAgB,CACZ,wBAAwB,EAAE,GAAG4B,SAAS,GAAG,CAAC,GAAG,UAAU,GAAG,OAAO,EAAE,EACnE,SAAS,CAAC;;;;QAKdA,SAAS,KAAK,CAAC,GAAG9B,0BAA0B,CACtB,IAAI,CAACyB,iBAAiB,EAAE,IAAI,CAACT,aAAa,EAC1C,IAAI,CAACJ,UAAU,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,CAACM,eAAe,CAAC,GACpDnB,sBAAsB,CAClB,IAAI,CAAC0B,iBAAiB,EAAE,IAAI,CAACT,aAAa,EAC1C,IAAI,CAACJ,UAAU,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,CAACM,eAAe,CAAC;KACzE;IACD,OAAOa,QAAQ;EACjB;;AAGF,OAAM,MAAOC,qBAAqB;EAahCvB,YACIC,WAAqB,EAAEuB,IAAA,GAAmB,IAAI,EAC9CC,UAAA,GAAsC,IAAI,EAC1CC,sBAAA,GAAqC,IAAI;IAb7C,KAAApB,QAAQ,GAAG,EAAE;IAGb,KAAAD,aAAa,GAAG,CAAC,GAAG,CAAC;IACrB,KAAAE,aAAa,GAA6B,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACpD,KAAAoB,IAAI,GAAG,IAAI;IAST,IAAI,CAAC1B,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACU,cAAc,GAAGb,kBAAkB,CAAC,IAAI,CAACG,WAAW,CAAC;IAC1D,IAAI,CAACiB,QAAQ,GAAGrB,eAAe,CAC3B,IAAI,CAACc,cAAc,EAAE,IAAI,CAACV,WAAW,EAAE,IAAI,CAACM,aAAa,CAAC;IAC9D,IAAI,CAACqB,OAAO,GAAGJ,IAAI,IAAI,IAAI;IAC3B,IAAI,CAACK,yBAAyB,GAAGH,sBAAsB,IAAI,IAAI;IAC/D,IAAI,CAACD,UAAU,GAAGA,UAAU;IAC5B,IAAI,IAAI,CAACG,OAAO,EAAE;MAChB,IAAI,CAACvB,aAAa,CAACyB,IAAI,CAAC,MAAM,CAAC;;IAGjC,IAAI,IAAI,CAACD,yBAAyB,EAAE;MAClC,IAAI,CAACxB,aAAa,CAACyB,IAAI,CAAC,wBAAwB,CAAC;;IAGnD,IAAI,CAACX,SAAS,GAAG,kBAAkBM,UAAU,EAAE;EACjD;EAEAL,WAAWA,CAAA;IACT,OAAO;MACLhC,mBAAmB,CAAC,IAAI,CAACqC,UAAU,EAAE,IAAI,CAACI,yBAAyB,CAAC;MACpElC,IAAI,CAAC,OAAO,CAAC;;;;UAITN,qBAAqB,CAAC,IAAI,CAACuC,OAAO,EAAE,IAAI,CAACH,UAAU,CAAC;;;;KAIzD;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}