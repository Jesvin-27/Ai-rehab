{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './flags_webgpu';\nimport { backend_util, buffer, DataStorage, engine, env, KernelBackend, util } from '@tensorflow/tfjs-core';\nimport { AdapterInfo } from './adapter_info';\nimport { BufferManager } from './buffer_manager';\nimport { TextureManager } from './texture_manager';\nimport * as webgpu_program from './webgpu_program';\nimport * as webgpu_util from './webgpu_util';\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD');\n// Reshape dispatch, not to exceed device limits.\nconst reshapeDispatch = (device, program) => {\n  const MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE = device.limits.maxComputeWorkgroupsPerDimension;\n  const layout = program['dispatchLayout'];\n  const dispatch = program['dispatch'];\n  if (dispatch.every(d => d <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE)) {\n    return dispatch;\n  }\n  util.assert(dispatch[0] > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE && layout.y === undefined && layout.z === undefined, () => 'Dispatch size exceeds WebGPU limits in Y or Z dimension.');\n  let dispatchAverage = Math.ceil(Math.sqrt(dispatch[0]));\n  if (dispatchAverage > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {\n    dispatchAverage = Math.ceil(Math.cbrt(dispatch[0]));\n    util.assert(dispatchAverage <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE, () => 'Total dispatch size exceeds WebGPU maximum.');\n    return [dispatchAverage, dispatchAverage, dispatchAverage];\n  } else {\n    return [dispatchAverage, dispatchAverage, 1];\n  }\n};\nclass WebGPUBackend extends KernelBackend {\n  nextDataId() {\n    return WebGPUBackend.nextDataId++;\n  }\n  constructor(device, adapterInfo) {\n    super();\n    this.commandQueueOwnedIds = new WeakSet();\n    this.dispatchCountInPass = 0;\n    this.disposed = false;\n    this.downloadWaitMs = 0;\n    this.tensorDataPendingDisposal = [];\n    this.queryResolveBuffer = null;\n    this.querySet = null;\n    this.querySetCount = 2;\n    this.stagingPendingDisposal = [];\n    this.uniformPendingDisposal = [];\n    this.uploadWaitMs = 0;\n    this.hasReadSyncWarned = false;\n    this.hasTimestampQueryWarned = false;\n    if (!webgpu_util.isWebGPUSupported()) {\n      throw new Error('WebGPU is not supported on this device');\n    }\n    this.pipelineCache = {};\n    this.device = device;\n    this.queue = device.queue;\n    this.commandEncoder = null;\n    this.computePassEncoder = null;\n    this.adapterInfo = new AdapterInfo(adapterInfo);\n    this.supportTimestampQuery = this.device.features.has('timestamp-query');\n    this.thresholdToIncreaseWorkgroups = this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8;\n    this.bufferManager = new BufferManager(this.device);\n    this.textureManager = new TextureManager(this.device);\n    this.tensorMap = new DataStorage(this, engine());\n    // Profiling tools like PIX needs this dummy canvas to\n    // trigger capturing a frame.\n    if (env().getBool('WEBGPU_USE_PROFILE_TOOL')) {\n      this.dummyCanvas = document.createElement('canvas');\n      this.dummyCanvas.width = 1;\n      this.dummyCanvas.height = 1;\n      this.dummyContext = this.dummyCanvas.getContext('webgpu');\n      this.dummyContext.configure({\n        device,\n        format: 'bgra8unorm'\n      });\n      document.body.appendChild(this.dummyCanvas);\n    }\n  }\n  floatPrecision() {\n    return 32;\n  }\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or delayed in this backend, false if there are still\n   * references.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  disposeData(dataId, force = false) {\n    // No-op if already disposed.\n    if (!this.tensorMap.has(dataId)) {\n      return true;\n    }\n    const tensorData = this.tensorMap.get(dataId);\n    if (force) {\n      tensorData.refCount = 0;\n    } else {\n      tensorData.refCount--;\n    }\n    if (tensorData.refCount > 0) {\n      return false;\n    }\n    if (tensorData.complexTensorInfos != null) {\n      this.disposeData(tensorData.complexTensorInfos.real.dataId);\n      this.disposeData(tensorData.complexTensorInfos.imag.dataId);\n    }\n    if (this.commandQueueOwnedIds.has(dataId)) {\n      this.tensorDataPendingDisposal.push(dataId);\n      return true;\n    }\n    this.releaseResource(dataId);\n    this.tensorMap.delete(dataId);\n    return true;\n  }\n  memory() {\n    return {\n      numBytesInGPU: this.bufferManager.numBytesUsed,\n      numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,\n      unreliable: false\n    };\n  }\n  releaseResource(dataId) {\n    const tensorData = this.tensorMap.get(dataId);\n    if (!tensorData || !tensorData.resource) {\n      return;\n    }\n    // If tensor's resource is from external, do not release.\n    if (tensorData.external) {\n      tensorData.resource = null;\n      return;\n    }\n    if (tensorData.resource instanceof GPUBuffer) {\n      this.bufferManager.releaseBuffer(tensorData.resource);\n    } else if (tensorData.resource instanceof GPUTexture) {\n      this.textureManager.releaseTexture(tensorData.resource);\n    }\n    tensorData.resource = null;\n  }\n  /** Return refCount of a `TensorData`. */\n  refCount(dataId) {\n    if (this.tensorMap.has(dataId)) {\n      const tensorData = this.tensorMap.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n  /** Increase refCount of a `TensorData`. */\n  incRef(dataId) {\n    const tensorData = this.tensorMap.get(dataId);\n    tensorData.refCount++;\n  }\n  /** Decrease refCount of a `TensorData`. */\n  decRef(dataId) {\n    if (this.tensorMap.has(dataId)) {\n      const tensorData = this.tensorMap.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n  write(values, shape, dtype) {\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {\n      id: this.nextDataId()\n    };\n    this.tensorMap.set(dataId, {\n      dtype,\n      shape,\n      values,\n      refCount: 1\n    });\n    return dataId;\n  }\n  move(dataId, values, shape, dtype, refCount) {\n    if (dtype === 'complex64') {\n      throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);\n    }\n    this.tensorMap.set(dataId, {\n      dtype,\n      shape,\n      values,\n      refCount\n    });\n  }\n  submitQueue() {\n    this.queue.submit([this.commandEncoder.finish()]);\n    this.commandEncoder = null;\n    this.dispatchCountInPass = 0;\n    this.commandQueueOwnedIds = new WeakSet();\n    this.tensorDataPendingDisposal.forEach(d => {\n      this.releaseResource(d);\n      this.tensorMap.delete(d);\n    });\n    this.uniformPendingDisposal.forEach(b => this.bufferManager.releaseBuffer(b));\n    this.stagingPendingDisposal.forEach(b => this.bufferManager.releaseBuffer(b, false));\n    this.tensorDataPendingDisposal = [];\n    this.uniformPendingDisposal = [];\n    this.stagingPendingDisposal = [];\n  }\n  ensureCommandEncoderReady() {\n    if (!this.commandEncoder) {\n      this.commandEncoder = this.device.createCommandEncoder();\n    }\n  }\n  endComputePassEncoder() {\n    if (this.computePassEncoder) {\n      this.computePassEncoder.end();\n      this.computePassEncoder = null;\n    }\n  }\n  // Check if parallel compilation is done.\n  async checkCompileCompletionAsync() {\n    let pipelines;\n    try {\n      pipelines = await Promise.all(Object.values(this.pipelineCache));\n    } catch (e) {\n      // TODO: Add test case to catch this exception.\n      throw new Error(e.message);\n    }\n    Object.keys(this.pipelineCache).map((key, i) => {\n      this.pipelineCache[key] = pipelines[i];\n    });\n  }\n  async getBufferData(buffer) {\n    if (env().getBool('WEBGPU_ENGINE_COMPILE_ONLY')) {\n      console.warn('The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false');\n      return null;\n    }\n    const size = buffer.size;\n    const stagingBuffer = this.bufferManager.acquireBuffer(size, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);\n    this.ensureCommandEncoderReady();\n    this.endComputePassEncoder();\n    this.commandEncoder.copyBufferToBuffer(buffer, 0, stagingBuffer, 0, size);\n    this.submitQueue();\n    await stagingBuffer.mapAsync(GPUMapMode.READ);\n    const values = stagingBuffer.getMappedRange().slice(0);\n    stagingBuffer.unmap();\n    if (stagingBuffer != null) {\n      this.bufferManager.releaseBuffer(stagingBuffer);\n    }\n    // Need to get texture from swapChain to enable profiling tool\n    // to capture a frame\n    if (env().getBool('WEBGPU_USE_PROFILE_TOOL')) {\n      util.assert(this.dummyContext !== undefined, () => `Fail to get context for profiling tool`);\n      this.dummyContext.getCurrentTexture();\n    }\n    return values;\n  }\n  convertAndCacheOnCPU(dataId, data) {\n    const tensorData = this.tensorMap.get(dataId);\n    tensorData.values = data;\n    return tensorData.values;\n  }\n  readSync(dataId) {\n    const tensorData = this.tensorMap.get(dataId);\n    const {\n      values,\n      complexTensorInfos\n    } = tensorData;\n    if (values != null || tensorData.dtype === 'string') {\n      return values;\n    }\n    if (tensorData.dtype === 'complex64') {\n      const realValues = this.readSync(complexTensorInfos.real.dataId);\n      const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n      const complexVals = util.convertBackendValuesAndArrayBuffer(backend_util.mergeRealAndImagArrays(realValues, imagValues).buffer, 'float32');\n      this.convertAndCacheOnCPU(dataId, complexVals);\n      return complexVals;\n    }\n    if (!this.hasReadSyncWarned) {\n      this.hasReadSyncWarned = true;\n      console.warn(`The performance of synchronously reading data from GPU to CPU is ` + `poor on the webgpu backend, please use asynchronous APIs instead.`);\n    }\n    const alphaModes = ['opaque', 'premultiplied'];\n    const buffer = tensorData.resource;\n    const bufferSize = buffer.size;\n    util.assert(bufferSize % 4 === 0, () => 'Because there is 4 bytes for ' + 'one pixel, buffer size must be multiple of 4.');\n    const pixelsSize = bufferSize / 4;\n    const valsGPU = new ArrayBuffer(bufferSize);\n    // TODO: adjust the reading window size according the `bufferSize`.\n    const canvasWidth = 256,\n      canvasHeight = 256;\n    const stagingDeviceStorage = alphaModes.map(_ => new OffscreenCanvas(canvasWidth, canvasHeight));\n    const stagingHostStorage = new OffscreenCanvas(canvasWidth, canvasHeight);\n    this.endComputePassEncoder();\n    stagingDeviceStorage.map((storage, index) => {\n      const context = storage.getContext('webgpu');\n      // TODO: use rgba8unorm format when this format is supported on Mac.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1298618\n      context.configure({\n        device: this.device,\n        format: 'bgra8unorm',\n        usage: GPUTextureUsage.COPY_DST,\n        alphaMode: alphaModes[index]\n      });\n      return context.getCurrentTexture();\n    }).map((texture, index) => {\n      const bytesPerRow = canvasWidth * 4;\n      const readDataGPUToCPU = (width, height, offset) => {\n        this.ensureCommandEncoderReady();\n        this.commandEncoder.copyBufferToTexture({\n          buffer,\n          bytesPerRow,\n          offset\n        }, {\n          texture\n        }, {\n          width,\n          height\n        });\n        this.submitQueue();\n        const context = stagingHostStorage.getContext('2d', {\n          willReadFrequently: true\n        });\n        context.clearRect(0, 0, width, height);\n        context.drawImage(stagingDeviceStorage[index], 0, 0);\n        const stagingValues = context.getImageData(0, 0, width, height).data;\n        const alphaMode = alphaModes[index];\n        const span = new Uint8ClampedArray(valsGPU, offset, width * height * 4);\n        for (let k = 0; k < span.length; k += 4) {\n          if (alphaMode === 'premultiplied') {\n            span[k + 3] = stagingValues[k + 3];\n          } else {\n            const value = stagingValues[k];\n            span[k] = stagingValues[k + 2];\n            span[k + 1] = stagingValues[k + 1];\n            span[k + 2] = value;\n          }\n        }\n      };\n      const fullyReadCount = Math.floor(pixelsSize / (canvasWidth * canvasHeight));\n      let width = canvasWidth,\n        height = canvasHeight,\n        offset = 0;\n      for (let i = 0; i < fullyReadCount; i++) {\n        // Read the buffer data, which fully fill the whole canvas.\n        readDataGPUToCPU(width, height, offset);\n        offset += canvasWidth * canvasHeight * 4;\n      }\n      const remainSize = pixelsSize % (canvasWidth * canvasHeight);\n      height = Math.floor(remainSize / canvasWidth);\n      if (height > 0) {\n        // Read the buffer data, which fully fill certain rows of canvas.\n        readDataGPUToCPU(width, height, offset);\n        offset += height * (canvasWidth * 4);\n      }\n      width = remainSize % canvasWidth;\n      if (width > 0) {\n        // Read the buffer data, which not fully fill one row of canvas.\n        readDataGPUToCPU(width, 1, offset);\n      }\n    });\n    const vals = util.convertBackendValuesAndArrayBuffer(valsGPU, tensorData.dtype);\n    this.convertAndCacheOnCPU(dataId, vals);\n    return vals;\n  }\n  async read(dataId) {\n    if (!this.tensorMap.has(dataId)) {\n      throw new Error(`Tensor ${dataId} was not registered!`);\n    }\n    const tensorData = this.tensorMap.get(dataId);\n    const {\n      values\n    } = tensorData;\n    if (values != null) {\n      return values;\n    }\n    // Download the values from the GPU.\n    let vals;\n    if (tensorData.dtype === 'complex64') {\n      const ps = await Promise.all([this.read(tensorData.complexTensorInfos.real.dataId), this.read(tensorData.complexTensorInfos.imag.dataId)]);\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      const data = await this.getBufferData(tensorData.resource);\n      vals = util.convertBackendValuesAndArrayBuffer(data, tensorData.dtype);\n    }\n    this.convertAndCacheOnCPU(dataId, vals);\n    return vals;\n  }\n  // The source GPUBuffer and destination GPUBuffer have the same size and\n  // usage.\n  copyBuffer(srcBuffer) {\n    const size = srcBuffer.size;\n    const usage = srcBuffer.usage;\n    const dstBuffer = this.bufferManager.acquireBuffer(size, usage);\n    this.ensureCommandEncoderReady();\n    this.endComputePassEncoder();\n    this.commandEncoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, size);\n    this.submitQueue();\n    return dstBuffer;\n  }\n  /**\n   * Create a TF.js tensor out of an existing WebGPU buffer.\n   */\n  createTensorFromGPUData(webGPUData, shape, dtype) {\n    let buffer = webGPUData.buffer;\n    if (dtype === 'complex64') {\n      throw new Error(`Cannot write to a complex64 dtype. `);\n    }\n    const dataId = {\n      id: this.nextDataId()\n    };\n    this.tensorMap.set(dataId, {\n      dtype,\n      shape,\n      values: null,\n      refCount: 1,\n      external: webGPUData.zeroCopy\n    });\n    const tensorData = this.tensorMap.get(dataId);\n    const size = webgpu_util.GPUBytesPerElement(tensorData.dtype) * util.sizeFromShape(tensorData.shape);\n    if (webGPUData.buffer.size < size) {\n      throw new Error(`GPUBuffer size(${webGPUData.buffer.size}) is smaller than tensor size(${size})!`);\n    } else if ((webGPUData.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !== (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) {\n      throw new Error('GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!');\n    }\n    // Do buffer copy by default.\n    if (webGPUData.zeroCopy !== true) {\n      buffer = this.copyBuffer(buffer);\n    }\n    tensorData.resource = buffer;\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n  }\n  /**\n   * Read tensor to a new GPUBuffer.\n   * @param dataId The source tensor.\n   */\n  readToGPU(dataId) {\n    const srcTensorData = this.tensorMap.get(dataId);\n    const {\n      values,\n      dtype,\n      shape,\n      resource\n    } = srcTensorData;\n    if (dtype === 'complex64') {\n      throw new Error('Does not support reading buffer for complex64 dtype.');\n    }\n    if (resource == null) {\n      if (values != null) {\n        throw new Error('Data is not on GPU but on CPU.');\n      } else {\n        throw new Error('There is no data on GPU or CPU.');\n      }\n    }\n    const srcBuffer = resource;\n    const size = srcBuffer.size;\n    const usage = srcBuffer.usage;\n    const buffer = this.bufferManager.acquireBuffer(size, usage);\n    this.ensureCommandEncoderReady();\n    this.endComputePassEncoder();\n    this.commandEncoder.copyBufferToBuffer(resource, 0, buffer, 0, size);\n    this.submitQueue();\n    const tensorInfo = this.makeTensorInfo(shape, dtype);\n    // Make engine track this tensor, so that we can dispose it later.\n    const tensorRef = engine().makeTensorFromTensorInfo(tensorInfo);\n    const tensorData = this.tensorMap.get(tensorInfo.dataId);\n    tensorData.resource = buffer;\n    return {\n      tensorRef,\n      buffer\n    };\n  }\n  bufferSync(t) {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = data.map(d => util.decodeString(d));\n        return buffer(t.shape, t.dtype, strings);\n      } catch (_a) {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape, t.dtype, data);\n  }\n  async time(f) {\n    if (!this.supportTimestampQuery && !this.hasTimestampQueryWarned) {\n      console.warn(`This device doesn't support timestamp-query extension. ` + `Start Chrome browser with flag ` + `--enable-dawn-features=allow_unsafe_apis to try it again. ` + `Otherwise, zero will be shown for the kernel time when profiling ` + `mode is enabled.`);\n      this.hasTimestampQueryWarned = true;\n    }\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers = [];\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n    f();\n    const flattenedActiveTimerQueries = util.flatten(this.activeTimers.map(d => d.query)).filter(d => d != null);\n    const flattenedActiveTimerNames = util.flatten(this.activeTimers.map(d => d.name)).filter(d => d != null);\n    this.activeTimers = oldActiveTimers;\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n    const res = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null\n    };\n    const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n    res['kernelMs'] = util.sum(kernelMs);\n    res['getExtraProfileInfo'] = () => kernelMs.map((d, i) => ({\n      name: flattenedActiveTimerNames[i],\n      ms: d\n    })).map(d => `${d.name}: ${d.ms}`).join(', ');\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    return res;\n  }\n  makeTensorInfo(shape, dtype, values) {\n    if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n      values = values.map(d => util.encodeString(d));\n    }\n    const dataId = this.write(values, shape, dtype);\n    return {\n      dataId,\n      shape,\n      dtype\n    };\n  }\n  tensorToBinding(tensor) {\n    if (!tensor) {\n      return null;\n    }\n    const tensorData = this.tensorMap.get(tensor.dataId);\n    const resource = tensorData.resource;\n    if (resource instanceof GPUBuffer) {\n      return {\n        buffer: resource\n      };\n    }\n    if (resource instanceof GPUTexture) {\n      return resource.createView();\n    }\n    // GPUExternalTexture\n    return resource;\n  }\n  uploadToGPU(dataId) {\n    const tensorData = this.tensorMap.get(dataId);\n    // Already on the GPU.\n    if (tensorData.resource != null) {\n      return;\n    }\n    const size = webgpu_util.GPUBytesPerElement(tensorData.dtype) * util.sizeFromShape(tensorData.shape);\n    let buffer;\n    const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    if (tensorData.values) {\n      buffer = this.bufferManager.acquireBuffer(size, usage, true);\n      if (buffer.mapState === 'unmapped') {\n        const stagingBuffer = this.bufferManager.acquireBuffer(size, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true, false);\n        const arrayBuffer = stagingBuffer.getMappedRange();\n        if (tensorData.dtype === 'int32' || tensorData.dtype === 'bool') {\n          new Int32Array(arrayBuffer).set(tensorData.values);\n        } else {\n          new Float32Array(arrayBuffer).set(tensorData.values);\n        }\n        stagingBuffer.unmap();\n        this.ensureCommandEncoderReady();\n        this.endComputePassEncoder();\n        this.commandEncoder.copyBufferToBuffer(stagingBuffer, 0, buffer, 0, size);\n        this.stagingPendingDisposal.push(stagingBuffer);\n      } else {\n        const arrayBuffer = buffer.getMappedRange();\n        if (tensorData.dtype === 'int32' || tensorData.dtype === 'bool') {\n          new Int32Array(arrayBuffer).set(tensorData.values);\n        } else {\n          new Float32Array(arrayBuffer).set(tensorData.values);\n        }\n        buffer.unmap();\n      }\n      // Once uploaded, don't store the values on cpu.\n      tensorData.values = null;\n    } else {\n      buffer = this.bufferManager.acquireBuffer(size, usage);\n    }\n    tensorData.resource = buffer;\n  }\n  makeUniforms(programUniform) {\n    let currentOffset = 0;\n    let preLength = 0;\n    const offsets = [];\n    let maxAlignmentOfField = 1;\n    programUniform.forEach(d => {\n      if (d.data.length === 0) {\n        d.data = [1];\n      }\n      // https://www.w3.org/TR/WGSL/#alignof\n      let baseAlignment;\n      switch (d.data.length) {\n        case 1:\n          baseAlignment = 4;\n          break;\n        case 2:\n          baseAlignment = 8;\n          break;\n        case 3:\n          baseAlignment = 16;\n          break;\n        case 4:\n          baseAlignment = 16;\n          break;\n        case 5:\n          baseAlignment = 16;\n          break;\n        case 6:\n          baseAlignment = 16;\n          break;\n        default:\n          util.assert(false, () => `Unsupported ${d.data.length}D shape`);\n      }\n      if (preLength === 5 || preLength === 6) {\n        baseAlignment = 16;\n      }\n      if (baseAlignment > maxAlignmentOfField) {\n        maxAlignmentOfField = baseAlignment;\n      }\n      currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;\n      preLength = d.data.length;\n      offsets.push(currentOffset);\n      currentOffset += d.data.length * 4;\n    });\n    currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;\n    const arrayBuffer = new ArrayBuffer(currentOffset);\n    programUniform.forEach((d, i) => {\n      const offset = offsets[i];\n      if (d.type === 'int32') {\n        new Int32Array(arrayBuffer, offset, d.data.length).set(d.data);\n      } else if (d.type === 'uint32') {\n        new Uint32Array(arrayBuffer, offset, d.data.length).set(d.data);\n      } else {\n        new Float32Array(arrayBuffer, offset, d.data.length).set(d.data);\n      }\n    });\n    const uniformBuffer = this.bufferManager.acquireBuffer(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);\n    this.queue.writeBuffer(uniformBuffer, 0, arrayBuffer, 0, currentOffset);\n    this.uniformPendingDisposal.push(uniformBuffer);\n    return {\n      offset: 0,\n      size: currentOffset,\n      buffer: uniformBuffer\n    };\n  }\n  runWebGPUProgram(program, inputs, outputDtype, programDefinedUniform, output) {\n    if (!output) {\n      output = this.makeTensorInfo(program.outputShape, outputDtype);\n    }\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      this.tensorMap.get(output.dataId).values = util.getTypedArrayFromDType(output.dtype, 0);\n      return output;\n    }\n    this.uploadToGPU(output.dataId);\n    program.dispatch = reshapeDispatch(this.device, program);\n    const inputsData = inputs.map((input, i) => {\n      if (input.dtype === 'complex64') {\n        throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` + `dtypes, please separate the program into real and imaginary ` + `parts.`);\n      }\n      this.uploadToGPU(input.dataId);\n      return {\n        // Returning dtype from tensorMap because it reflects dtype\n        // of underlying buffer, rather than abstract dtype.\n        dtype: this.tensorMap.get(input.dataId).dtype,\n        shape: input.shape,\n        name: program.variableNames[i]\n      };\n    });\n    program.shaderKey = webgpu_program.makeShaderKey(program, inputsData, output);\n    const parallelCompilation = env().getBool('WEBGPU_ENGINE_COMPILE_ONLY');\n    if (!(program.shaderKey in this.pipelineCache)) {\n      this.pipelineCache[program.shaderKey] = webgpu_program.compileProgram(this.device, program, inputsData, output, parallelCompilation);\n    }\n    program.pipeline = this.pipelineCache[program.shaderKey];\n    if (!parallelCompilation) {\n      this.recordAndSubmit(program, output, inputs, programDefinedUniform);\n    }\n    return output;\n  }\n  recordAndSubmit(program, output, inputs, programDefinedUniform) {\n    if (program.pipeline instanceof Promise) {\n      throw new Error('Please call checkCompileCompletionAsync to ensure parallel compilation is done!');\n    }\n    // There are six kinds of uniforms: NAN, INFINITY, shapes, shape strides,\n    // program size, program defined uniforms.\n    let programUniform = [];\n    let bufferShapes = [];\n    const uniformsType = 'int32';\n    if (program.pixelsOpType == null) {\n      programUniform.push({\n        type: 'float32',\n        data: [NaN]\n      }, {\n        type: 'float32',\n        data: [Infinity]\n      });\n      bufferShapes = inputs.concat(output).map(d => d.shape);\n      const uniformsType = 'int32';\n      bufferShapes.map(d => {\n        programUniform.push({\n          type: uniformsType,\n          data: d\n        });\n        const strides = util.computeStrides(d);\n        programUniform.push({\n          type: uniformsType,\n          data: strides\n        });\n      });\n    } else {\n      const strides = util.computeStrides(output.shape);\n      programUniform.push({\n        type: uniformsType,\n        data: strides\n      });\n    }\n    if (program.size) {\n      const size = util.sizeFromShape(program.outputShape);\n      programUniform.push({\n        type: uniformsType,\n        data: [program.outputComponent ? size / program.outputComponent : size]\n      });\n    }\n    if (programDefinedUniform) {\n      programUniform = [...programUniform, ...programDefinedUniform];\n    }\n    const bindings = [this.tensorToBinding(output), ...inputs.map(t => this.tensorToBinding(t)), this.makeUniforms(programUniform)];\n    inputs.forEach(input => {\n      this.commandQueueOwnedIds.add(input.dataId);\n    });\n    this.commandQueueOwnedIds.add(output.dataId);\n    const bindGroup = this.device.createBindGroup({\n      layout: program.pipeline.getBindGroupLayout(0),\n      entries: bindings.map((b, i) => ({\n        binding: i,\n        resource: b\n      }))\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    this.ensureCommandEncoderReady();\n    const computePassDescriptor = {};\n    if (shouldTimeProgram && this.supportTimestampQuery) {\n      this.endComputePassEncoder();\n      if (this.querySet == null) {\n        this.querySet = this.device.createQuerySet({\n          type: 'timestamp',\n          count: this.querySetCount\n        });\n      }\n      computePassDescriptor.timestampWrites = {\n        querySet: this.querySet,\n        beginningOfPassWriteIndex: 0,\n        endOfPassWriteIndex: 1\n      };\n      this.computePassEncoder = this.commandEncoder.beginComputePass(computePassDescriptor);\n    } else if (!this.computePassEncoder) {\n      this.computePassEncoder = this.commandEncoder.beginComputePass(computePassDescriptor);\n    }\n    this.computePassEncoder.setPipeline(program.pipeline);\n    this.computePassEncoder.setBindGroup(0, bindGroup);\n    this.computePassEncoder.dispatchWorkgroups(program.dispatch[0], program.dispatch[1], program.dispatch[2]);\n    this.dispatchCountInPass++;\n    if (shouldTimeProgram || env().get('WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE') <= this.dispatchCountInPass || program.pixelsOpType === webgpu_program.PixelsOpType.DRAW) {\n      this.endComputePassEncoder();\n      if (shouldTimeProgram) {\n        this.activeTimers.push({\n          name: program.constructor.name,\n          query: this.getQueryTime()\n        });\n      } else {\n        this.submitQueue();\n      }\n    }\n  }\n  async getQueryTime() {\n    if (!this.supportTimestampQuery) {\n      return 0;\n    }\n    if (this.queryResolveBuffer == null) {\n      this.queryResolveBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE);\n    }\n    this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);\n    const queryStagingBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, queryStagingBuffer, 0, this.querySetCount * 8);\n    this.submitQueue();\n    await queryStagingBuffer.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = new BigUint64Array(queryStagingBuffer.getMappedRange());\n    const time = Number(arrayBuffer[1] - arrayBuffer[0]) / 1000000;\n    queryStagingBuffer.unmap();\n    this.bufferManager.releaseBuffer(queryStagingBuffer);\n    return time;\n  }\n  shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {\n    return env().getBool('WEBGPU_CPU_FORWARD') && inputs.every(input => this.tensorMap.get(input.dataId).resource == null && util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n  numDataIds() {\n    return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;\n  }\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.querySet != null) {\n      this.querySet.destroy();\n    }\n    this.bufferManager.dispose();\n    this.textureManager.dispose();\n    this.disposed = true;\n  }\n}\nWebGPUBackend.nextDataId = 0;\nexport { WebGPUBackend };","map":{"version":3,"names":["backend_util","buffer","DataStorage","engine","env","KernelBackend","util","AdapterInfo","BufferManager","TextureManager","webgpu_program","webgpu_util","CPU_HANDOFF_SIZE_THRESHOLD","getNumber","reshapeDispatch","device","program","MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE","limits","maxComputeWorkgroupsPerDimension","layout","dispatch","every","d","assert","y","undefined","z","dispatchAverage","Math","ceil","sqrt","cbrt","WebGPUBackend","nextDataId","constructor","adapterInfo","commandQueueOwnedIds","WeakSet","dispatchCountInPass","disposed","downloadWaitMs","tensorDataPendingDisposal","queryResolveBuffer","querySet","querySetCount","stagingPendingDisposal","uniformPendingDisposal","uploadWaitMs","hasReadSyncWarned","hasTimestampQueryWarned","isWebGPUSupported","Error","pipelineCache","queue","commandEncoder","computePassEncoder","supportTimestampQuery","features","has","thresholdToIncreaseWorkgroups","intelGPUGeneration","bufferManager","textureManager","tensorMap","getBool","dummyCanvas","document","createElement","width","height","dummyContext","getContext","configure","format","body","appendChild","floatPrecision","disposeData","dataId","force","tensorData","get","refCount","complexTensorInfos","real","imag","push","releaseResource","delete","memory","numBytesInGPU","numBytesUsed","numBytesAllocatedInGPU","numBytesAllocated","unreliable","resource","external","GPUBuffer","releaseBuffer","GPUTexture","releaseTexture","incRef","decRef","write","values","shape","dtype","id","set","move","submitQueue","submit","finish","forEach","b","ensureCommandEncoderReady","createCommandEncoder","endComputePassEncoder","end","checkCompileCompletionAsync","pipelines","Promise","all","Object","e","message","keys","map","key","i","getBufferData","console","warn","size","stagingBuffer","acquireBuffer","GPUBufferUsage","COPY_DST","MAP_READ","copyBufferToBuffer","mapAsync","GPUMapMode","READ","getMappedRange","slice","unmap","getCurrentTexture","convertAndCacheOnCPU","data","readSync","realValues","imagValues","complexVals","convertBackendValuesAndArrayBuffer","mergeRealAndImagArrays","alphaModes","bufferSize","pixelsSize","valsGPU","ArrayBuffer","canvasWidth","canvasHeight","stagingDeviceStorage","_","OffscreenCanvas","stagingHostStorage","storage","index","context","usage","GPUTextureUsage","alphaMode","texture","bytesPerRow","readDataGPUToCPU","offset","copyBufferToTexture","willReadFrequently","clearRect","drawImage","stagingValues","getImageData","span","Uint8ClampedArray","k","length","value","fullyReadCount","floor","remainSize","vals","read","ps","copyBuffer","srcBuffer","dstBuffer","createTensorFromGPUData","webGPUData","zeroCopy","GPUBytesPerElement","sizeFromShape","STORAGE","COPY_SRC","makeTensorFromDataId","readToGPU","srcTensorData","tensorInfo","makeTensorInfo","tensorRef","makeTensorFromTensorInfo","bufferSync","t","strings","decodeString","_a","time","f","oldActiveTimers","activeTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","flatten","query","filter","flattenedActiveTimerNames","name","res","kernelMs","wallMs","sum","ms","join","isString","encodeString","tensorToBinding","tensor","createView","uploadToGPU","mapState","MAP_WRITE","arrayBuffer","Int32Array","Float32Array","makeUniforms","programUniform","currentOffset","preLength","offsets","maxAlignmentOfField","baseAlignment","type","Uint32Array","uniformBuffer","UNIFORM","writeBuffer","runWebGPUProgram","inputs","outputDtype","programDefinedUniform","output","outputShape","getTypedArrayFromDType","inputsData","input","variableNames","shaderKey","makeShaderKey","parallelCompilation","compileProgram","pipeline","recordAndSubmit","bufferShapes","uniformsType","pixelsOpType","NaN","Infinity","concat","strides","computeStrides","outputComponent","bindings","add","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","shouldTimeProgram","computePassDescriptor","createQuerySet","count","timestampWrites","beginningOfPassWriteIndex","endOfPassWriteIndex","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","PixelsOpType","DRAW","getQueryTime","QUERY_RESOLVE","resolveQuerySet","queryStagingBuffer","BigUint64Array","Number","shouldExecuteOnCPU","sizeThreshold","numDataIds","dispose","destroy"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/backend_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport './flags_webgpu';\n\nimport {backend_util, BackendValues, buffer, DataStorage, DataType, engine, env, GPUData, KernelBackend, Rank, RecursiveArray, ShapeMap, Tensor, TensorBuffer, TensorInfo, TimingInfo, TypedArray, util, WebGPUData} from '@tensorflow/tfjs-core';\n\nimport {AdapterInfo} from './adapter_info';\nimport {BufferManager} from './buffer_manager';\nimport {TextureManager} from './texture_manager';\nimport * as webgpu_program from './webgpu_program';\nimport * as webgpu_util from './webgpu_util';\n\nexport interface WebGPUMemoryInfo extends backend_util.MemoryInfo {\n  numBytesInGPU: number;\n  numBytesAllocatedInGPU: number;\n  unreliable: boolean;\n}\n\ntype TensorData = {\n  values: BackendValues,\n  dtype: DataType,\n  shape: number[],\n  refCount: number,\n  resource?: GPUBuffer|GPUTexture|GPUExternalTexture,\n  // external is true means we use the resource provided by users directly\n  // (without a copy), so users should be responsible for its release.\n  external?: boolean,\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensors, with a parent joining the two with the\n  // complexTensorInfos field.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo}\n};\n\ninterface DataId {}\n\nexport type WebGPUKernelInfo = {\n  name: string,\n  query: Promise<number>,\n};\n\nexport type TimerNode = RecursiveArray<WebGPUKernelInfo>|WebGPUKernelInfo;\n\nexport interface WebGPUTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\ntype ProgramUniform = Array<{type: string; data: number[]}>;\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD =\n    env().getNumber('WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD');\n\n// Reshape dispatch, not to exceed device limits.\nconst reshapeDispatch =\n    (device: GPUDevice,\n     program: webgpu_program.WebGPUProgram): [number, number, number] => {\n      const MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE =\n          device.limits.maxComputeWorkgroupsPerDimension;\n      const layout = program['dispatchLayout'];\n      const dispatch = program['dispatch'];\n      if (dispatch.every((d) => d <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE)) {\n        return dispatch;\n      }\n\n      util.assert(\n          dispatch[0] > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE &&\n              layout.y === undefined && layout.z === undefined,\n          () => 'Dispatch size exceeds WebGPU limits in Y or Z dimension.');\n\n      let dispatchAverage = Math.ceil(Math.sqrt(dispatch[0]));\n      if (dispatchAverage > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {\n        dispatchAverage = Math.ceil(Math.cbrt(dispatch[0]));\n        util.assert(\n            dispatchAverage <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE,\n            () => 'Total dispatch size exceeds WebGPU maximum.');\n        return [dispatchAverage, dispatchAverage, dispatchAverage];\n      } else {\n        return [dispatchAverage, dispatchAverage, 1];\n      }\n    };\n\nexport class WebGPUBackend extends KernelBackend {\n  bufferManager: BufferManager;\n  adapterInfo: AdapterInfo;\n  device: GPUDevice;\n  queue: GPUQueue;\n  tensorMap: DataStorage<TensorData>;\n  textureManager: TextureManager;\n  thresholdToIncreaseWorkgroups: number;\n\n  private activeTimers: TimerNode[];\n  private commandEncoder: GPUCommandEncoder;\n  private computePassEncoder: GPUComputePassEncoder;\n  private commandQueueOwnedIds = new WeakSet<DataId>();\n  private dispatchCountInPass = 0;\n  private disposed = false;\n  private downloadWaitMs = 0;\n  private dummyCanvas: HTMLCanvasElement;\n  private dummyContext: GPUCanvasContext;\n  private tensorDataPendingDisposal: DataId[] = [];\n  private static nextDataId = 0;\n  private pipelineCache:\n      {[key: string]: GPUComputePipeline|Promise<GPUComputePipeline>};\n  private programTimersStack: TimerNode[];\n  private queryResolveBuffer: GPUBuffer = null;\n  private querySet: GPUQuerySet = null;\n  private querySetCount = 2;\n  private stagingPendingDisposal: GPUBuffer[] = [];\n  private supportTimestampQuery: boolean;\n  private uniformPendingDisposal: GPUBuffer[] = [];\n  private uploadWaitMs = 0;\n  private hasReadSyncWarned = false;\n  private hasTimestampQueryWarned = false;\n\n  private nextDataId(): number {\n    return WebGPUBackend.nextDataId++;\n  }\n\n  constructor(device: GPUDevice, adapterInfo?: GPUAdapterInfo) {\n    super();\n    if (!webgpu_util.isWebGPUSupported()) {\n      throw new Error('WebGPU is not supported on this device');\n    }\n    this.pipelineCache = {};\n    this.device = device;\n    this.queue = device.queue;\n    this.commandEncoder = null;\n    this.computePassEncoder = null;\n    this.adapterInfo = new AdapterInfo(adapterInfo);\n    this.supportTimestampQuery = this.device.features.has('timestamp-query');\n    this.thresholdToIncreaseWorkgroups =\n        this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8;\n\n    this.bufferManager = new BufferManager(this.device);\n    this.textureManager = new TextureManager(this.device);\n    this.tensorMap = new DataStorage(this, engine());\n\n    // Profiling tools like PIX needs this dummy canvas to\n    // trigger capturing a frame.\n    if (env().getBool('WEBGPU_USE_PROFILE_TOOL')) {\n      this.dummyCanvas = document.createElement('canvas');\n      this.dummyCanvas.width = 1;\n      this.dummyCanvas.height = 1;\n\n      this.dummyContext = this.dummyCanvas.getContext('webgpu');\n      this.dummyContext.configure({\n        device,\n        format: 'bgra8unorm',\n      });\n\n      document.body.appendChild(this.dummyCanvas);\n    }\n  }\n\n  override floatPrecision(): 32 {\n    return 32;\n  }\n\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or delayed in this backend, false if there are still\n   * references.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  override disposeData(dataId: DataId, force = false): boolean {\n    // No-op if already disposed.\n    if (!this.tensorMap.has(dataId)) {\n      return true;\n    }\n\n    const tensorData = this.tensorMap.get(dataId);\n    if (force) {\n      tensorData.refCount = 0;\n    } else {\n      tensorData.refCount--;\n    }\n\n    if (tensorData.refCount > 0) {\n      return false;\n    }\n\n    if (tensorData.complexTensorInfos != null) {\n      this.disposeData(tensorData.complexTensorInfos.real.dataId);\n      this.disposeData(tensorData.complexTensorInfos.imag.dataId);\n    }\n\n    if (this.commandQueueOwnedIds.has(dataId)) {\n      this.tensorDataPendingDisposal.push(dataId);\n      return true;\n    }\n\n    this.releaseResource(dataId);\n    this.tensorMap.delete(dataId);\n\n    return true;\n  }\n\n  override memory(): WebGPUMemoryInfo {\n    return {\n      numBytesInGPU: this.bufferManager.numBytesUsed,\n      numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,\n      unreliable: false\n    } as WebGPUMemoryInfo;\n  }\n\n  private releaseResource(dataId: DataId) {\n    const tensorData = this.tensorMap.get(dataId);\n    if (!tensorData || !tensorData.resource) {\n      return;\n    }\n\n    // If tensor's resource is from external, do not release.\n    if (tensorData.external) {\n      tensorData.resource = null;\n      return;\n    }\n    if (tensorData.resource instanceof GPUBuffer) {\n      this.bufferManager.releaseBuffer(tensorData.resource);\n    } else if (tensorData.resource instanceof GPUTexture) {\n      this.textureManager.releaseTexture(tensorData.resource);\n    }\n    tensorData.resource = null;\n  }\n\n  /** Return refCount of a `TensorData`. */\n  override refCount(dataId: DataId): number {\n    if (this.tensorMap.has(dataId)) {\n      const tensorData = this.tensorMap.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TensorData`. */\n  override incRef(dataId: DataId): void {\n    const tensorData = this.tensorMap.get(dataId);\n    tensorData.refCount++;\n  }\n\n  /** Decrease refCount of a `TensorData`. */\n  decRef(dataId: DataId): void {\n    if (this.tensorMap.has(dataId)) {\n      const tensorData = this.tensorMap.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  override write(values: BackendValues, shape: number[], dtype: DataType):\n      DataId {\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {id: this.nextDataId()};\n    this.tensorMap.set(dataId, {dtype, shape, values, refCount: 1});\n    return dataId;\n  }\n\n  override move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void {\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.tensorMap.set(dataId, {dtype, shape, values, refCount});\n  }\n\n  submitQueue() {\n    this.queue.submit([this.commandEncoder.finish()]);\n    this.commandEncoder = null;\n    this.dispatchCountInPass = 0;\n\n    this.commandQueueOwnedIds = new WeakSet<DataId>();\n\n    this.tensorDataPendingDisposal.forEach(d => {\n      this.releaseResource(d);\n      this.tensorMap.delete(d);\n    });\n\n    this.uniformPendingDisposal.forEach(\n        b => this.bufferManager.releaseBuffer(b));\n    this.stagingPendingDisposal.forEach(\n        b => this.bufferManager.releaseBuffer(b, false));\n\n    this.tensorDataPendingDisposal = [];\n    this.uniformPendingDisposal = [];\n    this.stagingPendingDisposal = [];\n  }\n\n  ensureCommandEncoderReady() {\n    if (!this.commandEncoder) {\n      this.commandEncoder = this.device.createCommandEncoder();\n    }\n  }\n\n  endComputePassEncoder() {\n    if (this.computePassEncoder) {\n      this.computePassEncoder.end();\n      this.computePassEncoder = null;\n    }\n  }\n\n  // Check if parallel compilation is done.\n  async checkCompileCompletionAsync() {\n    let pipelines: GPUComputePipeline[];\n    try {\n      pipelines = await Promise.all(Object.values(this.pipelineCache));\n    } catch (e) {\n      // TODO: Add test case to catch this exception.\n      throw new Error(e.message);\n    }\n    Object.keys(this.pipelineCache).map((key, i) => {\n      this.pipelineCache[key] = pipelines[i];\n    });\n  }\n\n  public async getBufferData(buffer: GPUBuffer): Promise<ArrayBuffer> {\n    if (env().getBool('WEBGPU_ENGINE_COMPILE_ONLY')) {\n      console.warn(\n          'The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false');\n      return null;\n    }\n    const size = buffer.size;\n    const stagingBuffer = this.bufferManager.acquireBuffer(\n        size, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);\n    this.ensureCommandEncoderReady();\n    this.endComputePassEncoder();\n    this.commandEncoder.copyBufferToBuffer(buffer, 0, stagingBuffer, 0, size);\n    this.submitQueue();\n\n    await stagingBuffer.mapAsync(GPUMapMode.READ);\n    const values = stagingBuffer.getMappedRange().slice(0);\n\n    stagingBuffer.unmap();\n    if (stagingBuffer != null) {\n      this.bufferManager.releaseBuffer(stagingBuffer);\n    }\n\n    // Need to get texture from swapChain to enable profiling tool\n    // to capture a frame\n    if (env().getBool('WEBGPU_USE_PROFILE_TOOL')) {\n      util.assert(\n          this.dummyContext !== undefined,\n          () => `Fail to get context for profiling tool`);\n      this.dummyContext.getCurrentTexture();\n    }\n\n    return values;\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, data: BackendValues):\n      BackendValues {\n    const tensorData = this.tensorMap.get(dataId);\n    tensorData.values = data;\n    return tensorData.values;\n  }\n\n  override readSync(dataId: object): BackendValues {\n    const tensorData = this.tensorMap.get(dataId);\n    const {values, complexTensorInfos} = tensorData;\n\n    if (values != null || tensorData.dtype === 'string') {\n      return values;\n    }\n\n    if (tensorData.dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      const complexVals = util.convertBackendValuesAndArrayBuffer(\n          backend_util.mergeRealAndImagArrays(realValues, imagValues).buffer,\n          'float32');\n      this.convertAndCacheOnCPU(dataId, complexVals);\n      return complexVals;\n    }\n\n    if (!this.hasReadSyncWarned) {\n      this.hasReadSyncWarned = true;\n      console.warn(\n          `The performance of synchronously reading data from GPU to CPU is ` +\n          `poor on the webgpu backend, please use asynchronous APIs instead.`);\n    }\n\n    const alphaModes: GPUCanvasAlphaMode[] = ['opaque', 'premultiplied'];\n\n    const buffer = tensorData.resource as GPUBuffer;\n    const bufferSize = buffer.size;\n    util.assert(\n        bufferSize % 4 === 0,\n        () => 'Because there is 4 bytes for ' +\n            'one pixel, buffer size must be multiple of 4.');\n    const pixelsSize = bufferSize / 4;\n    const valsGPU = new ArrayBuffer(bufferSize);\n    // TODO: adjust the reading window size according the `bufferSize`.\n    const canvasWidth = 256, canvasHeight = 256;\n    const stagingDeviceStorage: OffscreenCanvas[] =\n        alphaModes.map(_ => new OffscreenCanvas(canvasWidth, canvasHeight));\n    const stagingHostStorage = new OffscreenCanvas(canvasWidth, canvasHeight);\n\n    this.endComputePassEncoder();\n    stagingDeviceStorage\n        .map((storage, index) => {\n          const context = storage.getContext('webgpu');\n          // TODO: use rgba8unorm format when this format is supported on Mac.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1298618\n          context.configure({\n            device: this.device,\n            format: 'bgra8unorm',\n            usage: GPUTextureUsage.COPY_DST,\n            alphaMode: alphaModes[index],\n          });\n          return context.getCurrentTexture();\n        })\n        .map((texture, index) => {\n          const bytesPerRow = canvasWidth * 4;\n          const readDataGPUToCPU =\n              (width: number, height: number, offset: number) => {\n                this.ensureCommandEncoderReady();\n                this.commandEncoder.copyBufferToTexture(\n                    {\n                      buffer,\n                      bytesPerRow,\n                      offset,\n                    },\n                    {\n                      texture,\n                    },\n                    {\n                      width,\n                      height,\n                    });\n                this.submitQueue();\n\n                const context = stagingHostStorage.getContext('2d', {\n                  willReadFrequently: true,\n                });\n                context.clearRect(0, 0, width, height);\n                context.drawImage(stagingDeviceStorage[index], 0, 0);\n                const stagingValues =\n                    context.getImageData(0, 0, width, height).data;\n                const alphaMode = alphaModes[index];\n                const span =\n                    new Uint8ClampedArray(valsGPU, offset, width * height * 4);\n                for (let k = 0; k < span.length; k += 4) {\n                  if (alphaMode === 'premultiplied') {\n                    span[k + 3] = stagingValues[k + 3];\n                  } else {\n                    const value = stagingValues[k];\n                    span[k] = stagingValues[k + 2];\n                    span[k + 1] = stagingValues[k + 1];\n                    span[k + 2] = value;\n                  }\n                }\n              };\n\n          const fullyReadCount =\n              Math.floor(pixelsSize / (canvasWidth * canvasHeight));\n          let width = canvasWidth, height = canvasHeight, offset = 0;\n          for (let i = 0; i < fullyReadCount; i++) {\n            // Read the buffer data, which fully fill the whole canvas.\n            readDataGPUToCPU(width, height, offset);\n            offset += canvasWidth * canvasHeight * 4;\n          }\n\n          const remainSize = pixelsSize % (canvasWidth * canvasHeight);\n          height = Math.floor(remainSize / canvasWidth);\n          if (height > 0) {\n            // Read the buffer data, which fully fill certain rows of canvas.\n            readDataGPUToCPU(width, height, offset);\n            offset += height * (canvasWidth * 4);\n          }\n\n          width = remainSize % canvasWidth;\n          if (width > 0) {\n            // Read the buffer data, which not fully fill one row of canvas.\n            readDataGPUToCPU(width, 1, offset);\n          }\n        });\n\n    const vals =\n        util.convertBackendValuesAndArrayBuffer(valsGPU, tensorData.dtype);\n    this.convertAndCacheOnCPU(dataId, vals);\n    return vals;\n  }\n\n  override async read(dataId: object): Promise<BackendValues> {\n    if (!this.tensorMap.has(dataId)) {\n      throw new Error(`Tensor ${dataId} was not registered!`);\n    }\n    const tensorData = this.tensorMap.get(dataId);\n\n    const {values} = tensorData;\n\n    if (values != null) {\n      return values;\n    }\n\n    // Download the values from the GPU.\n    let vals: BackendValues;\n    if (tensorData.dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(tensorData.complexTensorInfos.real.dataId),\n        this.read(tensorData.complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else {\n      const data = await this.getBufferData(tensorData.resource as GPUBuffer);\n      vals = util.convertBackendValuesAndArrayBuffer(data, tensorData.dtype);\n    }\n    this.convertAndCacheOnCPU(dataId, vals);\n    return vals;\n  }\n\n  // The source GPUBuffer and destination GPUBuffer have the same size and\n  // usage.\n  private copyBuffer(srcBuffer: GPUBuffer) {\n    const size = srcBuffer.size;\n    const usage = srcBuffer.usage;\n    const dstBuffer = this.bufferManager.acquireBuffer(size, usage);\n    this.ensureCommandEncoderReady();\n    this.endComputePassEncoder();\n    this.commandEncoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, size);\n    this.submitQueue();\n    return dstBuffer;\n  }\n\n  /**\n   * Create a TF.js tensor out of an existing WebGPU buffer.\n   */\n  override createTensorFromGPUData(\n      webGPUData: WebGPUData, shape: number[], dtype: DataType): Tensor {\n    let buffer = webGPUData.buffer;\n    if (dtype === 'complex64') {\n      throw new Error(`Cannot write to a complex64 dtype. `);\n    }\n    const dataId = {id: this.nextDataId()};\n    this.tensorMap.set(dataId, {\n      dtype,\n      shape,\n      values: null,\n      refCount: 1,\n      external: webGPUData.zeroCopy\n    });\n    const tensorData = this.tensorMap.get(dataId);\n    const size = webgpu_util.GPUBytesPerElement(tensorData.dtype) *\n        util.sizeFromShape(tensorData.shape);\n    if (webGPUData.buffer.size < size) {\n      throw new Error(`GPUBuffer size(${\n          webGPUData.buffer.size}) is smaller than tensor size(${size})!`);\n    } else if (\n        (webGPUData.buffer.usage &\n         (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !==\n        (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) {\n      throw new Error(\n          'GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!');\n    }\n\n    // Do buffer copy by default.\n    if (webGPUData.zeroCopy !== true) {\n      buffer = this.copyBuffer(buffer);\n    }\n    tensorData.resource = buffer;\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n  }\n\n  /**\n   * Read tensor to a new GPUBuffer.\n   * @param dataId The source tensor.\n   */\n  override readToGPU(dataId: DataId): GPUData {\n    const srcTensorData = this.tensorMap.get(dataId);\n    const {values, dtype, shape, resource} = srcTensorData;\n\n    if (dtype === 'complex64') {\n      throw new Error('Does not support reading buffer for complex64 dtype.');\n    }\n\n    if (resource == null) {\n      if (values != null) {\n        throw new Error('Data is not on GPU but on CPU.');\n      } else {\n        throw new Error('There is no data on GPU or CPU.');\n      }\n    }\n\n    const srcBuffer = resource as GPUBuffer;\n    const size = srcBuffer.size;\n    const usage = srcBuffer.usage;\n    const buffer = this.bufferManager.acquireBuffer(size, usage);\n    this.ensureCommandEncoderReady();\n    this.endComputePassEncoder();\n    this.commandEncoder.copyBufferToBuffer(\n        resource as GPUBuffer, 0, buffer, 0, size);\n    this.submitQueue();\n\n    const tensorInfo = this.makeTensorInfo(shape, dtype);\n    // Make engine track this tensor, so that we can dispose it later.\n    const tensorRef = engine().makeTensorFromTensorInfo(tensorInfo);\n\n    const tensorData = this.tensorMap.get(tensorInfo.dataId);\n    tensorData.resource = buffer;\n\n    return {tensorRef, buffer};\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  override async time(f: () => void): Promise<WebGPUTimingInfo> {\n    if (!this.supportTimestampQuery && !this.hasTimestampQueryWarned) {\n      console.warn(\n          `This device doesn't support timestamp-query extension. ` +\n          `Start Chrome browser with flag ` +\n          `--enable-dawn-features=allow_unsafe_apis to try it again. ` +\n          `Otherwise, zero will be shown for the kernel time when profiling ` +\n          `mode is enabled.`);\n      this.hasTimestampQueryWarned = true;\n    }\n\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: WebGPUKernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: WebGPUKernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n    const res: WebGPUTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null\n    };\n\n    const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n    res['kernelMs'] = util.sum(kernelMs);\n    res['getExtraProfileInfo'] = () =>\n        kernelMs.map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n            .map(d => `${d.name}: ${d.ms}`)\n            .join(', ');\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    return res;\n  }\n\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: BackendValues|string[]): TensorInfo {\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      values = (values as unknown as string[]).map(d => util.encodeString(d));\n    }\n    const dataId = this.write(values as BackendValues, shape, dtype);\n    return {dataId, shape, dtype};\n  }\n\n  private tensorToBinding(tensor?: TensorInfo): GPUBindingResource {\n    if (!tensor) {\n      return null;\n    }\n\n    const tensorData = this.tensorMap.get(tensor.dataId);\n    const resource = tensorData.resource;\n\n    if (resource instanceof GPUBuffer) {\n      return {buffer: resource};\n    }\n    if (resource instanceof GPUTexture) {\n      return resource.createView();\n    }\n    // GPUExternalTexture\n    return resource;\n  }\n\n  uploadToGPU(dataId: DataId): void {\n    const tensorData = this.tensorMap.get(dataId);\n    // Already on the GPU.\n    if (tensorData.resource != null) {\n      return;\n    }\n\n    const size = webgpu_util.GPUBytesPerElement(tensorData.dtype) *\n        util.sizeFromShape(tensorData.shape);\n    let buffer;\n    const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST;\n    if (tensorData.values) {\n      buffer = this.bufferManager.acquireBuffer(size, usage, true);\n      if (buffer.mapState === 'unmapped') {\n        const stagingBuffer = this.bufferManager.acquireBuffer(\n            size, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true,\n            false);\n        const arrayBuffer = stagingBuffer.getMappedRange();\n        if (tensorData.dtype === 'int32' || tensorData.dtype === 'bool') {\n          new Int32Array(arrayBuffer).set(tensorData.values as TypedArray);\n        } else {\n          new Float32Array(arrayBuffer).set(tensorData.values as Float32Array);\n        }\n        stagingBuffer.unmap();\n        this.ensureCommandEncoderReady();\n        this.endComputePassEncoder();\n        this.commandEncoder.copyBufferToBuffer(\n            stagingBuffer, 0, buffer, 0, size);\n\n        this.stagingPendingDisposal.push(stagingBuffer);\n      } else {\n        const arrayBuffer = buffer.getMappedRange();\n        if (tensorData.dtype === 'int32' || tensorData.dtype === 'bool') {\n          new Int32Array(arrayBuffer).set(tensorData.values as TypedArray);\n        } else {\n          new Float32Array(arrayBuffer).set(tensorData.values as Float32Array);\n        }\n        buffer.unmap();\n      }\n\n      // Once uploaded, don't store the values on cpu.\n      tensorData.values = null;\n    } else {\n      buffer = this.bufferManager.acquireBuffer(size, usage);\n    }\n    tensorData.resource = buffer;\n  }\n\n  private makeUniforms(programUniform: ProgramUniform): GPUBindingResource {\n    let currentOffset = 0;\n    let preLength = 0;\n    const offsets: number[] = [];\n    let maxAlignmentOfField = 1;\n    programUniform.forEach((d) => {\n      if (d.data.length === 0) {\n        d.data = [1];\n      }\n      // https://www.w3.org/TR/WGSL/#alignof\n      let baseAlignment: number;\n      switch (d.data.length) {\n        case 1:\n          baseAlignment = 4;\n          break;\n        case 2:\n          baseAlignment = 8;\n          break;\n        case 3:\n          baseAlignment = 16;\n          break;\n        case 4:\n          baseAlignment = 16;\n          break;\n        case 5:\n          baseAlignment = 16;\n          break;\n        case 6:\n          baseAlignment = 16;\n          break;\n        default:\n          util.assert(false, () => `Unsupported ${d.data.length}D shape`);\n      }\n\n      if (preLength === 5 || preLength === 6) {\n        baseAlignment = 16;\n      }\n      if (baseAlignment > maxAlignmentOfField) {\n        maxAlignmentOfField = baseAlignment;\n      }\n      currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;\n      preLength = d.data.length;\n      offsets.push(currentOffset);\n      currentOffset += d.data.length * 4;\n    });\n\n    currentOffset =\n        Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;\n    const arrayBuffer = new ArrayBuffer(currentOffset);\n    programUniform.forEach((d, i) => {\n      const offset = offsets[i];\n      if (d.type === 'int32') {\n        new Int32Array(arrayBuffer, offset, d.data.length).set(d.data);\n      } else if (d.type === 'uint32') {\n        new Uint32Array(arrayBuffer, offset, d.data.length).set(d.data);\n      } else {\n        new Float32Array(arrayBuffer, offset, d.data.length).set(d.data);\n      }\n    });\n\n    const uniformBuffer = this.bufferManager.acquireBuffer(\n        currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);\n    this.queue.writeBuffer(uniformBuffer, 0, arrayBuffer, 0, currentOffset);\n    this.uniformPendingDisposal.push(uniformBuffer);\n\n    return {offset: 0, size: currentOffset, buffer: uniformBuffer};\n  }\n\n  public runWebGPUProgram(\n      program: webgpu_program.WebGPUProgram, inputs: TensorInfo[],\n      outputDtype: DataType, programDefinedUniform?: ProgramUniform,\n      output?: TensorInfo): TensorInfo {\n    if (!output) {\n      output = this.makeTensorInfo(program.outputShape, outputDtype);\n    }\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      this.tensorMap.get(output.dataId).values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n    this.uploadToGPU(output.dataId);\n    program.dispatch = reshapeDispatch(this.device, program);\n\n    const inputsData = inputs.map((input: TensorInfo, i: number) => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n      this.uploadToGPU(input.dataId);\n\n      return {\n        // Returning dtype from tensorMap because it reflects dtype\n        // of underlying buffer, rather than abstract dtype.\n        dtype: this.tensorMap.get(input.dataId).dtype,\n        shape: input.shape,\n        name: program.variableNames[i]\n      };\n    });\n\n    program.shaderKey =\n        webgpu_program.makeShaderKey(program, inputsData, output);\n\n    const parallelCompilation = env().getBool('WEBGPU_ENGINE_COMPILE_ONLY');\n    if (!(program.shaderKey in this.pipelineCache)) {\n      this.pipelineCache[program.shaderKey] = webgpu_program.compileProgram(\n          this.device, program, inputsData, output, parallelCompilation);\n    }\n    program.pipeline = this.pipelineCache[program.shaderKey];\n\n    if (!parallelCompilation) {\n      this.recordAndSubmit(program, output, inputs, programDefinedUniform);\n    }\n    return output;\n  }\n\n  private recordAndSubmit(\n      program: webgpu_program.WebGPUProgram, output: TensorInfo,\n      inputs: TensorInfo[], programDefinedUniform?: ProgramUniform) {\n    if (program.pipeline instanceof Promise) {\n      throw new Error(\n          'Please call checkCompileCompletionAsync to ensure parallel compilation is done!');\n    }\n    // There are six kinds of uniforms: NAN, INFINITY, shapes, shape strides,\n    // program size, program defined uniforms.\n    let programUniform: ProgramUniform = [];\n    let bufferShapes: number[][] = [];\n    const uniformsType = 'int32';\n    if (program.pixelsOpType == null) {\n      programUniform.push(\n          {type: 'float32', data: [NaN]}, {type: 'float32', data: [Infinity]});\n      bufferShapes = inputs.concat(output).map(d => d.shape);\n      const uniformsType = 'int32';\n      bufferShapes.map(d => {\n        programUniform.push({type: uniformsType, data: d});\n        const strides = util.computeStrides(d);\n        programUniform.push({type: uniformsType, data: strides});\n      });\n    } else {\n      const strides = util.computeStrides(output.shape);\n      programUniform.push({type: uniformsType, data: strides});\n    }\n    if (program.size) {\n      const size = util.sizeFromShape(program.outputShape);\n      programUniform.push({\n        type: uniformsType,\n        data: [program.outputComponent ? size / program.outputComponent : size]\n      });\n    }\n\n    if (programDefinedUniform) {\n      programUniform = [...programUniform, ...programDefinedUniform];\n    }\n    const bindings = [\n      this.tensorToBinding(output), ...inputs.map(t => this.tensorToBinding(t)),\n      this.makeUniforms(programUniform)\n    ];\n\n    inputs.forEach(input => {\n      this.commandQueueOwnedIds.add(input.dataId);\n    });\n    this.commandQueueOwnedIds.add(output.dataId);\n\n    const bindGroup = this.device.createBindGroup({\n      layout: program.pipeline.getBindGroupLayout(0),\n      entries: bindings.map((b, i) => ({binding: i, resource: b})),\n    });\n\n    const shouldTimeProgram = this.activeTimers != null;\n    this.ensureCommandEncoderReady();\n\n    const computePassDescriptor: GPUComputePassDescriptor = {};\n    if (shouldTimeProgram && this.supportTimestampQuery) {\n      this.endComputePassEncoder();\n      if (this.querySet == null) {\n        this.querySet = this.device.createQuerySet({\n          type: 'timestamp',\n          count: this.querySetCount,\n        });\n      }\n      computePassDescriptor.timestampWrites = {\n        querySet: this.querySet,\n        beginningOfPassWriteIndex: 0,\n        endOfPassWriteIndex: 1,\n      };\n      this.computePassEncoder =\n          this.commandEncoder.beginComputePass(computePassDescriptor);\n    } else if (!this.computePassEncoder) {\n      this.computePassEncoder =\n          this.commandEncoder.beginComputePass(computePassDescriptor);\n    }\n\n    this.computePassEncoder.setPipeline(program.pipeline);\n    this.computePassEncoder.setBindGroup(0, bindGroup);\n    this.computePassEncoder.dispatchWorkgroups(\n        program.dispatch[0], program.dispatch[1], program.dispatch[2]);\n    this.dispatchCountInPass++;\n\n    if (shouldTimeProgram ||\n        env().get('WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE') as\n            number <= this.dispatchCountInPass ||\n        program.pixelsOpType === webgpu_program.PixelsOpType.DRAW) {\n      this.endComputePassEncoder();\n      if (shouldTimeProgram) {\n        this.activeTimers.push(\n            {name: program.constructor.name, query: this.getQueryTime()});\n      } else {\n        this.submitQueue();\n      }\n    }\n  }\n\n  async getQueryTime(): Promise<number> {\n    if (!this.supportTimestampQuery) {\n      return 0;\n    }\n\n    if (this.queryResolveBuffer == null) {\n      this.queryResolveBuffer = this.bufferManager.acquireBuffer(\n          this.querySetCount * 8,\n          GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST |\n              GPUBufferUsage.QUERY_RESOLVE);\n    }\n    this.commandEncoder.resolveQuerySet(\n        this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);\n\n    const queryStagingBuffer = this.bufferManager.acquireBuffer(\n        this.querySetCount * 8,\n        GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n\n    this.commandEncoder.copyBufferToBuffer(\n        this.queryResolveBuffer, 0, queryStagingBuffer, 0,\n        this.querySetCount * 8);\n\n    this.submitQueue();\n\n    await queryStagingBuffer.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = new BigUint64Array(queryStagingBuffer.getMappedRange());\n    const time = Number(arrayBuffer[1] - arrayBuffer[0]) / 1000000;\n    queryStagingBuffer.unmap();\n    this.bufferManager.releaseBuffer(queryStagingBuffer);\n    return time;\n  }\n\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return env().getBool('WEBGPU_CPU_FORWARD') &&\n        inputs.every(\n            input => this.tensorMap.get(input.dataId).resource == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  override numDataIds() {\n    return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;\n  }\n\n  override dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.querySet != null) {\n      this.querySet.destroy();\n    }\n    this.bufferManager.dispose();\n    this.textureManager.dispose();\n    this.disposed = true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}