{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { atomicAddSnippet } from './shader_util';\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class SparseSegmentSumProgram {\n  constructor(outShape, sparseSize, outputDtype) {\n    this.variableNames = ['input', 'indices', 'segmentIds'];\n    this.outputShape = [];\n    this.uniforms = 'segmentSize : i32, sparseSize : i32,';\n    this.workgroupSize = [64, 1, 1];\n    this.atomic = true;\n    this.outputShape = outShape;\n    this.type = outputDtype;\n    this.dispatchLayout = flatDispatchLayout([sparseSize]);\n    this.dispatch = computeDispatch(this.dispatchLayout, [sparseSize], this.workgroupSize);\n    this.shaderKey = 'sparseSegmentSum';\n  }\n  getUserCode() {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${atomicAddSnippet('&result[outIndex]', 'value', this.type)}\n      }\n    }\n  `;\n    return userCode;\n  }\n}\nexport class SparseSegmentIdCountProgram {\n  constructor(outShape, segmentIdsShape) {\n    this.variableNames = ['segmentIds'];\n    this.outputShape = [];\n    this.workgroupSize = [64, 1, 1];\n    this.atomic = true;\n    this.outputShape = [outShape];\n    this.dispatchLayout = flatDispatchLayout(segmentIdsShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, segmentIdsShape, this.workgroupSize);\n    this.shaderKey = 'sparseSegmentIdCountProgram';\n  }\n  getUserCode() {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${atomicAddSnippet('&result[segmentId]', '1', 'int32')}\n      }\n    }\n  `;\n    return userCode;\n  }\n}\nexport class SparseSegmentMeanProgram {\n  constructor(outShape, outputDtype) {\n    this.variableNames = ['segmentSum', 'sameSegmentIdCount'];\n    this.outputShape = [];\n    this.uniforms = 'segmentSize : i32';\n    this.workgroupSize = [64, 1, 1];\n    this.size = true;\n    this.outputShape = outShape;\n    this.type = outputDtype;\n    this.dispatchLayout = flatDispatchLayout(outShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, outShape, this.workgroupSize);\n    this.shaderKey = 'sparseSegmentMean';\n  }\n  getUserCode() {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${this.type === 'float32' ? 'setOutputAtIndex(index, segmentSum[index] / f32(count));' : 'setOutputAtIndexI32(index, segmentSum[index] / count);'}\n        }\n      }\n    }\n  `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["atomicAddSnippet","getMainHeaderString","main","computeDispatch","flatDispatchLayout","SparseSegmentSumProgram","constructor","outShape","sparseSize","outputDtype","variableNames","outputShape","uniforms","workgroupSize","atomic","type","dispatchLayout","dispatch","shaderKey","getUserCode","userCode","SparseSegmentIdCountProgram","segmentIdsShape","SparseSegmentMeanProgram","size"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/sparse_segment_reduce_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType} from '@tensorflow/tfjs-core';\n\nimport {atomicAddSnippet} from './shader_util';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class SparseSegmentSumProgram implements WebGPUProgram {\n  variableNames = ['input', 'indices', 'segmentIds'];\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  uniforms = 'segmentSize : i32, sparseSize : i32,';\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  atomic = true;\n  type: DataType;\n\n  constructor(outShape: number[], sparseSize: number, outputDtype: DataType) {\n    this.outputShape = outShape;\n    this.type = outputDtype;\n    this.dispatchLayout = flatDispatchLayout([sparseSize]);\n    this.dispatch =\n        computeDispatch(this.dispatchLayout, [sparseSize], this.workgroupSize);\n\n    this.shaderKey = 'sparseSegmentSum';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${\n        atomicAddSnippet(\n            '&result[outIndex]', 'value', this.type as 'float32' | 'int32')}\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n\nexport class SparseSegmentIdCountProgram implements WebGPUProgram {\n  variableNames = ['segmentIds'];\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  atomic = true;\n\n  constructor(outShape: number, segmentIdsShape: number[]) {\n    this.outputShape = [outShape];\n    this.dispatchLayout = flatDispatchLayout(segmentIdsShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, segmentIdsShape, this.workgroupSize);\n\n    this.shaderKey = 'sparseSegmentIdCountProgram';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${atomicAddSnippet('&result[segmentId]', '1', 'int32')}\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n\nexport class SparseSegmentMeanProgram implements WebGPUProgram {\n  variableNames = ['segmentSum', 'sameSegmentIdCount'];\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  uniforms = 'segmentSize : i32';\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  size = true;\n  type: DataType;\n\n  constructor(outShape: number[], outputDtype: DataType) {\n    this.outputShape = outShape;\n    this.type = outputDtype;\n    this.dispatchLayout = flatDispatchLayout(outShape);\n    this.dispatch =\n        computeDispatch(this.dispatchLayout, outShape, this.workgroupSize);\n\n    this.shaderKey = 'sparseSegmentMean';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${\n        this.type === 'float32' ?\n            'setOutputAtIndex(index, segmentSum[index] / f32(count));' :\n            'setOutputAtIndexI32(index, segmentSum[index] / count);'}\n        }\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}