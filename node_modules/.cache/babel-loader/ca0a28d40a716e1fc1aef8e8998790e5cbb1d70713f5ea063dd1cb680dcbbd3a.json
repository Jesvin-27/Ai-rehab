{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport var UnaryOpType;\n(function (UnaryOpType) {\n  UnaryOpType[UnaryOpType[\"ABS\"] = 0] = \"ABS\";\n  UnaryOpType[UnaryOpType[\"ACOS\"] = 1] = \"ACOS\";\n  UnaryOpType[UnaryOpType[\"ACOSH\"] = 2] = \"ACOSH\";\n  UnaryOpType[UnaryOpType[\"ASIN\"] = 3] = \"ASIN\";\n  UnaryOpType[UnaryOpType[\"ASINH\"] = 4] = \"ASINH\";\n  UnaryOpType[UnaryOpType[\"ATAN\"] = 5] = \"ATAN\";\n  UnaryOpType[UnaryOpType[\"ATANH\"] = 6] = \"ATANH\";\n  UnaryOpType[UnaryOpType[\"CEIL\"] = 7] = \"CEIL\";\n  UnaryOpType[UnaryOpType[\"COS\"] = 8] = \"COS\";\n  UnaryOpType[UnaryOpType[\"COSH\"] = 9] = \"COSH\";\n  UnaryOpType[UnaryOpType[\"ELU\"] = 10] = \"ELU\";\n  UnaryOpType[UnaryOpType[\"ERF\"] = 11] = \"ERF\";\n  UnaryOpType[UnaryOpType[\"EXP\"] = 12] = \"EXP\";\n  UnaryOpType[UnaryOpType[\"EXPM1\"] = 13] = \"EXPM1\";\n  UnaryOpType[UnaryOpType[\"FLOOR\"] = 14] = \"FLOOR\";\n  UnaryOpType[UnaryOpType[\"IS_FINITE\"] = 15] = \"IS_FINITE\";\n  UnaryOpType[UnaryOpType[\"IS_INF\"] = 16] = \"IS_INF\";\n  UnaryOpType[UnaryOpType[\"IS_NAN\"] = 17] = \"IS_NAN\";\n  UnaryOpType[UnaryOpType[\"LINEAR\"] = 18] = \"LINEAR\";\n  UnaryOpType[UnaryOpType[\"LOG\"] = 19] = \"LOG\";\n  UnaryOpType[UnaryOpType[\"LOG1P\"] = 20] = \"LOG1P\";\n  UnaryOpType[UnaryOpType[\"LOGICAL_NOT\"] = 21] = \"LOGICAL_NOT\";\n  UnaryOpType[UnaryOpType[\"NEG\"] = 22] = \"NEG\";\n  UnaryOpType[UnaryOpType[\"RELU\"] = 23] = \"RELU\";\n  UnaryOpType[UnaryOpType[\"RELU6\"] = 24] = \"RELU6\";\n  UnaryOpType[UnaryOpType[\"LEAKYRELU\"] = 25] = \"LEAKYRELU\";\n  UnaryOpType[UnaryOpType[\"RECIPROCAL\"] = 26] = \"RECIPROCAL\";\n  UnaryOpType[UnaryOpType[\"ROUND\"] = 27] = \"ROUND\";\n  UnaryOpType[UnaryOpType[\"RSQRT\"] = 28] = \"RSQRT\";\n  UnaryOpType[UnaryOpType[\"SELU\"] = 29] = \"SELU\";\n  UnaryOpType[UnaryOpType[\"SIGMOID\"] = 30] = \"SIGMOID\";\n  UnaryOpType[UnaryOpType[\"SIGN\"] = 31] = \"SIGN\";\n  UnaryOpType[UnaryOpType[\"SIN\"] = 32] = \"SIN\";\n  UnaryOpType[UnaryOpType[\"SINH\"] = 33] = \"SINH\";\n  UnaryOpType[UnaryOpType[\"SOFTPLUS\"] = 34] = \"SOFTPLUS\";\n  UnaryOpType[UnaryOpType[\"SQRT\"] = 35] = \"SQRT\";\n  UnaryOpType[UnaryOpType[\"SQUARE\"] = 36] = \"SQUARE\";\n  UnaryOpType[UnaryOpType[\"STEP\"] = 37] = \"STEP\";\n  UnaryOpType[UnaryOpType[\"TAN\"] = 38] = \"TAN\";\n  UnaryOpType[UnaryOpType[\"TANH\"] = 39] = \"TANH\";\n  UnaryOpType[UnaryOpType[\"TO_INT\"] = 40] = \"TO_INT\";\n})(UnaryOpType || (UnaryOpType = {}));\nconst ABS = `return abs(a);`;\nconst ACOS = `\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n`;\nconst ACOSH = `\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n`;\nconst ASIN = `\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n`;\nconst ASINH = `return asinh(a);`;\nconst ATAN = `\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n`;\nconst ATANH = `\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n`;\nconst CEIL = `return ceil(a);`;\nconst COS = `return cos(a);`;\nconst COSH = `\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\nconst EXPM1 = `return exp(a) - 1.0;`;\nconst ELU = `if (a >= 0.0) { return a; }  return (exp(a) - 1.0);`;\nconst ELU_VEC4 = `\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n`;\nconst ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  let p = ${backend_util.ERF_P};\n  let a1 = ${backend_util.ERF_A1};\n  let a2 = ${backend_util.ERF_A2};\n  let a3 = ${backend_util.ERF_A3};\n  let a4 = ${backend_util.ERF_A4};\n  let a5 = ${backend_util.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`;\nconst EXP = `return exp(a);`;\nconst FLOOR = `return floor(a);`;\nconst IS_FINITE = `return f32(!isnan(a) && !isinf(a));`;\nconst IS_INF = `return f32(isinf(a));`;\nconst IS_NAN = `return f32(isnan(a));`;\nconst LINEAR = `return a;`;\nconst LOG = `if (a < 0.0) { return uniforms.NAN; }\n  return log(a);`;\nconst LOG1P = `\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n`;\nconst LOGICAL_NOT = `return f32(!(a >= 1.0));`;\nconst NEG = `return -a;`;\nconst LEAKYRELU = `if (a < 0.0) { return uniforms.alpha * a; } return a;`;\nconst LEAKYRELU_VEC4 = `\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n`;\nconst RECIPROCAL = `return 1.0 / a;`;\nconst RELU = `return select(a, 0.0, a < 0.0);`;\nconst RELU6 = 'return clamp(a, 0.0, 6.0);';\nconst RELU6_VEC4 = 'return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));';\nconst RELU_VEC4 = `\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n`;\nconst ROUND = `return round(a);`;\nconst RSQRT = `return inverseSqrt(a);`;\n// Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n// See: https://arxiv.org/abs/1706.02515\nconst SELU = `\n  if (a >= 0.0) {\n    return ${backend_util.SELU_SCALE} * a;\n  } else {\n    return ${backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;\nconst SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * a));`;\nconst SIGN = `return sign(a);`;\nconst SIN = `return sin(a);`;\nconst SINH = `\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\nconst SOFTPLUS = `\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n`;\nconst SQRT = `return sqrt(a);`;\nconst SQUARE = `return a * a;`;\nconst STEP = `\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n`;\nconst TAN = `return tan(a);`;\nconst TANH = `\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n`;\nconst TO_INT = `return f32(i32((a)));`;\nexport function getUnaryOpString(type, useVec4) {\n  switch (type) {\n    case UnaryOpType.ABS:\n      return ABS;\n    case UnaryOpType.ACOS:\n      return ACOS;\n    case UnaryOpType.ACOSH:\n      return ACOSH;\n    case UnaryOpType.ASIN:\n      return ASIN;\n    case UnaryOpType.ASINH:\n      return ASINH;\n    case UnaryOpType.ATAN:\n      return ATAN;\n    case UnaryOpType.ATANH:\n      return ATANH;\n    case UnaryOpType.COS:\n      return COS;\n    case UnaryOpType.COSH:\n      return COSH;\n    case UnaryOpType.CEIL:\n      return CEIL;\n    case UnaryOpType.ELU:\n      return useVec4 ? ELU_VEC4 : ELU;\n    case UnaryOpType.ERF:\n      return ERF;\n    case UnaryOpType.EXP:\n      return EXP;\n    case UnaryOpType.EXPM1:\n      return EXPM1;\n    case UnaryOpType.FLOOR:\n      return FLOOR;\n    case UnaryOpType.IS_FINITE:\n      return IS_FINITE;\n    case UnaryOpType.IS_INF:\n      return IS_INF;\n    case UnaryOpType.IS_NAN:\n      return IS_NAN;\n    case UnaryOpType.LINEAR:\n      return LINEAR;\n    case UnaryOpType.LOG:\n      return LOG;\n    case UnaryOpType.LOG1P:\n      return LOG1P;\n    case UnaryOpType.LOGICAL_NOT:\n      return LOGICAL_NOT;\n    case UnaryOpType.NEG:\n      return NEG;\n    case UnaryOpType.LEAKYRELU:\n      return useVec4 ? LEAKYRELU_VEC4 : LEAKYRELU;\n    case UnaryOpType.RECIPROCAL:\n      return RECIPROCAL;\n    case UnaryOpType.RELU:\n      return useVec4 ? RELU_VEC4 : RELU;\n    case UnaryOpType.RELU6:\n      return useVec4 ? RELU6_VEC4 : RELU6;\n    case UnaryOpType.ROUND:\n      return ROUND;\n    case UnaryOpType.RSQRT:\n      return RSQRT;\n    case UnaryOpType.SELU:\n      return SELU;\n    case UnaryOpType.SIGMOID:\n      return SIGMOID;\n    case UnaryOpType.SIGN:\n      return SIGN;\n    case UnaryOpType.SIN:\n      return SIN;\n    case UnaryOpType.SINH:\n      return SINH;\n    case UnaryOpType.SOFTPLUS:\n      return SOFTPLUS;\n    case UnaryOpType.SQRT:\n      return SQRT;\n    case UnaryOpType.SQUARE:\n      return SQUARE;\n    case UnaryOpType.STEP:\n      return STEP;\n    case UnaryOpType.TAN:\n      return TAN;\n    case UnaryOpType.TANH:\n      return TANH;\n    case UnaryOpType.TO_INT:\n      return TO_INT;\n    default:\n      throw new Error(`BinaryType ${type} is not implemented!`);\n  }\n}","map":{"version":3,"names":["backend_util","UnaryOpType","ABS","ACOS","ACOSH","ASIN","ASINH","ATAN","ATANH","CEIL","COS","COSH","EXPM1","ELU","ELU_VEC4","ERF","ERF_P","ERF_A1","ERF_A2","ERF_A3","ERF_A4","ERF_A5","EXP","FLOOR","IS_FINITE","IS_INF","IS_NAN","LINEAR","LOG","LOG1P","LOGICAL_NOT","NEG","LEAKYRELU","LEAKYRELU_VEC4","RECIPROCAL","RELU","RELU6","RELU6_VEC4","RELU_VEC4","ROUND","RSQRT","SELU","SELU_SCALE","SELU_SCALEALPHA","SIGMOID","SIGN","SIN","SINH","SOFTPLUS","SQRT","SQUARE","STEP","TAN","TANH","TO_INT","getUnaryOpString","type","useVec4","Error"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/unary_op_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nexport enum UnaryOpType {\n  ABS,\n  ACOS,\n  ACOSH,\n  ASIN,\n  ASINH,\n  ATAN,\n  ATANH,\n  CEIL,\n  COS,\n  COSH,\n  ELU,\n  ERF,\n  EXP,\n  EXPM1,\n  FLOOR,\n  IS_FINITE,\n  IS_INF,\n  IS_NAN,\n  LINEAR,\n  LOG,\n  LOG1P,\n  LOGICAL_NOT,\n  NEG,\n  RELU,\n  RELU6,\n  LEAKYRELU,\n  RECIPROCAL,\n  ROUND,\n  RSQRT,\n  SELU,\n  SIGMOID,\n  SIGN,\n  SIN,\n  SINH,\n  SOFTPLUS,\n  SQRT,\n  SQUARE,\n  STEP,\n  TAN,\n  TANH,\n  TO_INT\n}\n\nconst ABS = `return abs(a);`;\nconst ACOS = `\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n`;\nconst ACOSH = `\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n`;\nconst ASIN = `\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n`;\nconst ASINH = `return asinh(a);`;\nconst ATAN = `\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n`;\nconst ATANH = `\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n`;\nconst CEIL = `return ceil(a);`;\nconst COS = `return cos(a);`;\nconst COSH = `\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\nconst EXPM1 = `return exp(a) - 1.0;`;\nconst ELU = `if (a >= 0.0) { return a; }  return (exp(a) - 1.0);`;\nconst ELU_VEC4 = `\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n`;\nconst ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  let p = ${backend_util.ERF_P};\n  let a1 = ${backend_util.ERF_A1};\n  let a2 = ${backend_util.ERF_A2};\n  let a3 = ${backend_util.ERF_A3};\n  let a4 = ${backend_util.ERF_A4};\n  let a5 = ${backend_util.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`;\nconst EXP = `return exp(a);`;\nconst FLOOR = `return floor(a);`;\nconst IS_FINITE = `return f32(!isnan(a) && !isinf(a));`;\nconst IS_INF = `return f32(isinf(a));`;\nconst IS_NAN = `return f32(isnan(a));`;\nconst LINEAR = `return a;`;\nconst LOG = `if (a < 0.0) { return uniforms.NAN; }\n  return log(a);`;\nconst LOG1P = `\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n`;\nconst LOGICAL_NOT = `return f32(!(a >= 1.0));`;\nconst NEG = `return -a;`;\nconst LEAKYRELU = `if (a < 0.0) { return uniforms.alpha * a; } return a;`;\nconst LEAKYRELU_VEC4 = `\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n`;\nconst RECIPROCAL = `return 1.0 / a;`;\nconst RELU = `return select(a, 0.0, a < 0.0);`;\nconst RELU6 = 'return clamp(a, 0.0, 6.0);';\nconst RELU6_VEC4 =\n    'return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));';\nconst RELU_VEC4 = `\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n`;\nconst ROUND = `return round(a);`;\nconst RSQRT = `return inverseSqrt(a);`;\n// Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n// See: https://arxiv.org/abs/1706.02515\nconst SELU = `\n  if (a >= 0.0) {\n    return ${backend_util.SELU_SCALE} * a;\n  } else {\n    return ${backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;\nconst SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * a));`;\nconst SIGN = `return sign(a);`;\nconst SIN = `return sin(a);`;\nconst SINH = `\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\nconst SOFTPLUS = `\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n`;\nconst SQRT = `return sqrt(a);`;\nconst SQUARE = `return a * a;`;\nconst STEP = `\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n`;\nconst TAN = `return tan(a);`;\nconst TANH = `\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n`;\nconst TO_INT = `return f32(i32((a)));`;\n\nexport function getUnaryOpString(type: UnaryOpType, useVec4?: boolean): string {\n  switch (type) {\n    case UnaryOpType.ABS:\n      return ABS;\n    case UnaryOpType.ACOS:\n      return ACOS;\n    case UnaryOpType.ACOSH:\n      return ACOSH;\n    case UnaryOpType.ASIN:\n      return ASIN;\n    case UnaryOpType.ASINH:\n      return ASINH;\n    case UnaryOpType.ATAN:\n      return ATAN;\n    case UnaryOpType.ATANH:\n      return ATANH;\n    case UnaryOpType.COS:\n      return COS;\n    case UnaryOpType.COSH:\n      return COSH;\n    case UnaryOpType.CEIL:\n      return CEIL;\n    case UnaryOpType.ELU:\n      return useVec4 ? ELU_VEC4 : ELU;\n    case UnaryOpType.ERF:\n      return ERF;\n    case UnaryOpType.EXP:\n      return EXP;\n    case UnaryOpType.EXPM1:\n      return EXPM1;\n    case UnaryOpType.FLOOR:\n      return FLOOR;\n    case UnaryOpType.IS_FINITE:\n      return IS_FINITE;\n    case UnaryOpType.IS_INF:\n      return IS_INF;\n    case UnaryOpType.IS_NAN:\n      return IS_NAN;\n    case UnaryOpType.LINEAR:\n      return LINEAR;\n    case UnaryOpType.LOG:\n      return LOG;\n    case UnaryOpType.LOG1P:\n      return LOG1P;\n    case UnaryOpType.LOGICAL_NOT:\n      return LOGICAL_NOT;\n    case UnaryOpType.NEG:\n      return NEG;\n    case UnaryOpType.LEAKYRELU:\n      return useVec4 ? LEAKYRELU_VEC4 : LEAKYRELU;\n    case UnaryOpType.RECIPROCAL:\n      return RECIPROCAL;\n    case UnaryOpType.RELU:\n      return useVec4 ? RELU_VEC4 : RELU;\n    case UnaryOpType.RELU6:\n      return useVec4 ? RELU6_VEC4 : RELU6;\n    case UnaryOpType.ROUND:\n      return ROUND;\n    case UnaryOpType.RSQRT:\n      return RSQRT;\n    case UnaryOpType.SELU:\n      return SELU;\n    case UnaryOpType.SIGMOID:\n      return SIGMOID;\n    case UnaryOpType.SIGN:\n      return SIGN;\n    case UnaryOpType.SIN:\n      return SIN;\n    case UnaryOpType.SINH:\n      return SINH;\n    case UnaryOpType.SOFTPLUS:\n      return SOFTPLUS;\n    case UnaryOpType.SQRT:\n      return SQRT;\n    case UnaryOpType.SQUARE:\n      return SQUARE;\n    case UnaryOpType.STEP:\n      return STEP;\n    case UnaryOpType.TAN:\n      return TAN;\n    case UnaryOpType.TANH:\n      return TANH;\n    case UnaryOpType.TO_INT:\n      return TO_INT;\n\n    default:\n      throw new Error(`BinaryType ${type} is not implemented!`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}