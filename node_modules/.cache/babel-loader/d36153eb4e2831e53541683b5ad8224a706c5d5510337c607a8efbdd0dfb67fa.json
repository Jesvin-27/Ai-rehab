{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nconst powOperatorSnippet = `\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n`;\nexport class LRNProgram {\n  constructor(xShape) {\n    this.outputShape = [];\n    this.variableNames = ['x'];\n    this.uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n    this.workgroupSize = [64, 1, 1];\n    this.size = true;\n    this.outputShape = xShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.shaderKey = 'lrn';\n  }\n  getUserCode() {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${powOperatorSnippet}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `;\n    return userCode;\n  }\n}\nexport class LRNSharedProgram {\n  constructor(xShape, radius) {\n    this.outputShape = [];\n    this.variableNames = ['x'];\n    this.uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n    this.workgroupSize = [256, 1, 1];\n    this.maxAllowRadius = 16;\n    util.assert(radius <= this.maxAllowRadius, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${radius}`);\n    this.outputShape = xShape;\n    // The reason why not using this.workgroupSize[0] + 2 * maxAllowRadius here\n    // is to make sure that there is only one time global memory load access for\n    // each thread.\n    this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius;\n    this.dispatchLayout = {\n      x: [3],\n      y: [2],\n      z: [0, 1]\n    };\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2]]);\n    this.shaderKey = 'lrn_shared';\n  }\n  getUserCode() {\n    const userCode = `\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${main()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${powOperatorSnippet}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["util","getMainHeaderString","main","computeDispatch","flatDispatchLayout","powOperatorSnippet","LRNProgram","constructor","xShape","outputShape","variableNames","uniforms","workgroupSize","size","dispatchLayout","dispatch","shaderKey","getUserCode","userCode","LRNSharedProgram","radius","maxAllowRadius","assert","elementsPerWorkgroup","x","y","z"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/lrn_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nconst powOperatorSnippet = `\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n`;\n\nexport class LRNProgram implements WebGPUProgram {\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  size = true;\n\n  constructor(xShape: number[]) {\n    this.outputShape = xShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.shaderKey = 'lrn';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${powOperatorSnippet}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n\nexport class LRNSharedProgram implements WebGPUProgram {\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n  workgroupSize: [number, number, number] = [256, 1, 1];\n  maxAllowRadius = 16;\n  elementsPerWorkgroup: number;\n\n  constructor(xShape: number[], radius: number) {\n    util.assert(\n        radius <= this.maxAllowRadius,\n        () => `Radius must be less than or equal to ${\n            this.maxAllowRadius}, current radius is ${radius}`);\n\n    this.outputShape = xShape;\n    // The reason why not using this.workgroupSize[0] + 2 * maxAllowRadius here\n    // is to make sure that there is only one time global memory load access for\n    // each thread.\n    this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius;\n    this.dispatchLayout = {x: [3], y: [2], z: [0, 1]};\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [\n      this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2]\n    ]);\n    this.shaderKey = 'lrn_shared';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${main()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${powOperatorSnippet}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,IAAI,QAAO,uBAAuB;AAC1C,SAAQC,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AAC3E,SAAQC,eAAe,EAAEC,kBAAkB,QAAO,eAAe;AAEjE,MAAMC,kBAAkB,GAAG;;;;;;;;;;CAU1B;AAED,OAAM,MAAOC,UAAU;EAUrBC,YAAYC,MAAgB;IAT5B,KAAAC,WAAW,GAAa,EAAE;IAI1B,KAAAC,aAAa,GAAG,CAAC,GAAG,CAAC;IACrB,KAAAC,QAAQ,GAAG,oDAAoD;IAC/D,KAAAC,aAAa,GAA6B,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACpD,KAAAC,IAAI,GAAG,IAAI;IAGT,IAAI,CAACJ,WAAW,GAAGD,MAAM;IACzB,IAAI,CAACM,cAAc,GAAGV,kBAAkB,CAAC,IAAI,CAACK,WAAW,CAAC;IAC1D,IAAI,CAACM,QAAQ,GAAGZ,eAAe,CAC3B,IAAI,CAACW,cAAc,EAAE,IAAI,CAACL,WAAW,EAAE,IAAI,CAACG,aAAa,CAAC;IAC9D,IAAI,CAACI,SAAS,GAAG,KAAK;EACxB;EAEAC,WAAWA,CAAA;IACT,MAAMC,QAAQ,GAAG;MACfhB,IAAI,CAAC,OAAO,CAAC;;;;;;;;;;;;;;;;;UAiBTG,kBAAkB;;;;;GAKzB;IACC,OAAOa,QAAQ;EACjB;;AAGF,OAAM,MAAOC,gBAAgB;EAW3BZ,YAAYC,MAAgB,EAAEY,MAAc;IAV5C,KAAAX,WAAW,GAAa,EAAE;IAI1B,KAAAC,aAAa,GAAG,CAAC,GAAG,CAAC;IACrB,KAAAC,QAAQ,GAAG,oDAAoD;IAC/D,KAAAC,aAAa,GAA6B,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;IACrD,KAAAS,cAAc,GAAG,EAAE;IAIjBrB,IAAI,CAACsB,MAAM,CACPF,MAAM,IAAI,IAAI,CAACC,cAAc,EAC7B,MAAM,wCACF,IAAI,CAACA,cAAc,uBAAuBD,MAAM,EAAE,CAAC;IAE3D,IAAI,CAACX,WAAW,GAAGD,MAAM;IACzB;IACA;IACA;IACA,IAAI,CAACe,oBAAoB,GAAG,IAAI,CAACX,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAACS,cAAc;IAC3E,IAAI,CAACP,cAAc,GAAG;MAACU,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC;IACjD,IAAI,CAACX,QAAQ,GAAGZ,eAAe,CAAC,IAAI,CAACW,cAAc,EAAE,IAAI,CAACL,WAAW,EAAE,CACrE,IAAI,CAACc,oBAAoB,EAAE,IAAI,CAACX,aAAa,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,aAAa,CAAC,CAAC,CAAC,CACxE,CAAC;IACF,IAAI,CAACI,SAAS,GAAG,YAAY;EAC/B;EAEAC,WAAWA,CAAA;IACT,MAAMC,QAAQ,GAAG;wCACmB,IAAI,CAACN,aAAa,CAAC,CAAC,CAAC;mCAC1B,IAAI,CAACW,oBAAoB;6BAC/B,IAAI,CAACF,cAAc;;MAE1CnB,IAAI,EAAE;;;;;;;;;;;;;;;;;;;;;;;UAuBFG,kBAAkB;;;;OAIrB;IACH,OAAOa,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}