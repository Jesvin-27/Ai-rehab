{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class Pool2DProgram {\n  constructor(convInfo, poolType, computePositions = false, flattenPositions = false, includeBatchIndex = false) {\n    this.variableNames = ['x'];\n    this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,`;\n    // TODO(jiajia.qin@intel.com): Dynamically choose different workgroupSize for\n    // different output shapes.\n    this.workgroupSize = [128, 1, 1];\n    this.size = true;\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = `pool2D_${poolType}_${computePositions}_${flattenPositions}_${includeBatchIndex}`;\n  }\n  getUserCode() {\n    let updateSnippet;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ? this.includeBatchIndex ? `((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d` : `(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d` : `wR * uniforms.filterDims.y + wC`;\n      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${positionStr};\n      }`;\n    } else {\n      updateSnippet = `resultValue = max(value, resultValue);`;\n    }\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / max(count, 1.0)`;\n    }\n    const userCode = `\n      ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions ? `var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;` : `var resultValue = ${this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${updateSnippet}\n            }\n          }\n\n          ${this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` : `setOutputAtIndex(index, ${returnValue});`}\n        }\n      }\n    `;\n    return userCode;\n  }\n}\nexport class Pool3DProgram {\n  constructor(convInfo, poolType, computePositions = false, flattenPositions = false, includeBatchIndex = false) {\n    this.variableNames = ['x'];\n    this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,`;\n    this.workgroupSize = [128, 1, 1];\n    this.size = true;\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = `pool3D_${poolType}_${computePositions}_${flattenPositions}_${includeBatchIndex}`;\n  }\n  getUserCode() {\n    let updateSnippet;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue += value; count += 1.0;`;\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ? this.includeBatchIndex ? `(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch` : `((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch` : `wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC`;\n      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${positionStr};\n      }`;\n    } else {\n      updateSnippet = `resultValue = max(value, resultValue);`;\n    }\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / max(count, 1.0)`;\n    }\n    const userCode = `\n      ${main('index')} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions ? `var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;` : `var resultValue = ${this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${updateSnippet}\n              }\n            }\n          }\n\n          ${this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` : `setOutputAtIndex(index, ${returnValue});`}\n        }\n      }\n    `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["getMainHeaderString","main","computeDispatch","flatDispatchLayout","Pool2DProgram","constructor","convInfo","poolType","computePositions","flattenPositions","includeBatchIndex","variableNames","uniforms","workgroupSize","size","Error","outputShape","outShape","dispatchLayout","dispatch","shaderKey","getUserCode","updateSnippet","positionStr","returnValue","userCode","Pool3DProgram"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/pool_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class Pool2DProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms =\n      `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,`;\n  // TODO(jiajia.qin@intel.com): Dynamically choose different workgroupSize for\n  // different output shapes.\n  workgroupSize: [number, number, number] = [128, 1, 1];\n  poolType: 'max'|'avg';\n  size = true;\n  computePositions: boolean;\n  flattenPositions: boolean;\n  includeBatchIndex: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions = false, flattenPositions = false,\n      includeBatchIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = `pool2D_${poolType}_${computePositions}_${\n        flattenPositions}_${includeBatchIndex}`;\n  }\n\n  getUserCode(): string {\n    let updateSnippet: string;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ?\n          (this.includeBatchIndex ?\n               `((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d` :\n               `(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d`) :\n          `wR * uniforms.filterDims.y + wC`;\n      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${positionStr};\n      }`;\n    } else {\n      updateSnippet = `resultValue = max(value, resultValue);`;\n    }\n\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / max(count, 1.0)`;\n    }\n\n    const userCode = `\n      ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${\n        this.computePositions ?\n            `var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;` :\n            `var resultValue = ${\n                this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${updateSnippet}\n            }\n          }\n\n          ${\n        this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` :\n                                `setOutputAtIndex(index, ${returnValue});`}\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n\nexport class Pool3DProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms =\n      `strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,`;\n  workgroupSize: [number, number, number] = [128, 1, 1];\n  poolType: 'max'|'avg';\n  size = true;\n  computePositions: boolean;\n  flattenPositions: boolean;\n  includeBatchIndex: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions = false, flattenPositions = false,\n      includeBatchIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = `pool3D_${poolType}_${computePositions}_${\n        flattenPositions}_${includeBatchIndex}`;\n  }\n\n  getUserCode(): string {\n    let updateSnippet: string;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue += value; count += 1.0;`;\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ?\n          (this.includeBatchIndex ?\n               `(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch` :\n               `((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch`) :\n          `wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC`;\n      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${positionStr};\n      }`;\n    } else {\n      updateSnippet = `resultValue = max(value, resultValue);`;\n    }\n\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / max(count, 1.0)`;\n    }\n\n    const userCode = `\n      ${main('index')} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${\n        this.computePositions ?\n            `var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;` :\n            `var resultValue = ${\n                this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${updateSnippet}\n              }\n            }\n          }\n\n          ${\n        this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` :\n                                `setOutputAtIndex(index, ${returnValue});`}\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}