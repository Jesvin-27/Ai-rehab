{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var BinaryOpType;\n(function (BinaryOpType) {\n  BinaryOpType[BinaryOpType[\"ADD\"] = 0] = \"ADD\";\n  BinaryOpType[BinaryOpType[\"ATAN2\"] = 1] = \"ATAN2\";\n  BinaryOpType[BinaryOpType[\"COMPLEX_MULTIPLY_IMAG\"] = 2] = \"COMPLEX_MULTIPLY_IMAG\";\n  BinaryOpType[BinaryOpType[\"COMPLEX_MULTIPLY_REAL\"] = 3] = \"COMPLEX_MULTIPLY_REAL\";\n  BinaryOpType[BinaryOpType[\"DIV\"] = 4] = \"DIV\";\n  BinaryOpType[BinaryOpType[\"ELU_DER\"] = 5] = \"ELU_DER\";\n  BinaryOpType[BinaryOpType[\"EQUAL\"] = 6] = \"EQUAL\";\n  BinaryOpType[BinaryOpType[\"FLOOR_DIV\"] = 7] = \"FLOOR_DIV\";\n  BinaryOpType[BinaryOpType[\"GREATER\"] = 8] = \"GREATER\";\n  BinaryOpType[BinaryOpType[\"GREATER_EQUAL\"] = 9] = \"GREATER_EQUAL\";\n  BinaryOpType[BinaryOpType[\"LESS\"] = 10] = \"LESS\";\n  BinaryOpType[BinaryOpType[\"LESS_EQUAL\"] = 11] = \"LESS_EQUAL\";\n  BinaryOpType[BinaryOpType[\"LOGICAL_AND\"] = 12] = \"LOGICAL_AND\";\n  BinaryOpType[BinaryOpType[\"LOGICAL_OR\"] = 13] = \"LOGICAL_OR\";\n  BinaryOpType[BinaryOpType[\"MAX\"] = 14] = \"MAX\";\n  BinaryOpType[BinaryOpType[\"MIN\"] = 15] = \"MIN\";\n  BinaryOpType[BinaryOpType[\"MOD\"] = 16] = \"MOD\";\n  BinaryOpType[BinaryOpType[\"MUL\"] = 17] = \"MUL\";\n  BinaryOpType[BinaryOpType[\"NOT_EQUAL\"] = 18] = \"NOT_EQUAL\";\n  BinaryOpType[BinaryOpType[\"POW\"] = 19] = \"POW\";\n  BinaryOpType[BinaryOpType[\"PRELU\"] = 20] = \"PRELU\";\n  BinaryOpType[BinaryOpType[\"SQUARED_DIFFERENCE\"] = 21] = \"SQUARED_DIFFERENCE\";\n  BinaryOpType[BinaryOpType[\"SUB\"] = 22] = \"SUB\";\n})(BinaryOpType || (BinaryOpType = {}));\nconst ADD = 'let resultTemp = a + b;';\nconst ATAN2 = 'let resultTemp = atan2(a, b);';\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nconst COMPLEX_MULTIPLY_REAL = 'let resultTemp = areal * breal - aimag * bimag;';\nconst COMPLEX_MULTIPLY_IMAG = 'let resultTemp = areal * bimag + aimag * breal;';\nconst DIV = 'let resultTemp = a / b;';\nconst ELU_DER = 'let resultTemp = select(a * (b + 1.0), a, b >= b - b);';\nconst EQUAL = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n`;\nconst FLOOR_DIV = `\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n`;\nconst GREATER = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n`;\nconst GREATER_EQUAL = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n`;\nconst LESS = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n`;\nconst LESS_EQUAL = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n`;\nconst LOGICAL_AND = 'return f32(a >= 1.0 && b >= 1.0);';\nconst LOGICAL_AND_VEC4 = `return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));`;\nconst LOGICAL_OR = 'return f32(a >= 1.0 || b >= 1.0);';\nconst LOGICAL_OR_VEC4 = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`;\nconst MAX = 'let resultTemp = max(a, b);';\nconst MIN = 'let resultTemp = min(a, b);';\nconst MOD = `\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n`;\nconst MOD_VEC4 = `\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n`;\nconst MUL = 'let resultTemp = a * b;';\nconst NOT_EQUAL = `\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n`;\nconst NOT_EQUAL_VEC4 = `\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n`;\nconst POW = `\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n`;\nconst POW_VEC4 = `\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n`;\nconst PRELU = `if (a < 0.0) { return b * a; }  return a;`;\nconst PRELU_VEC4 = `\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n`;\nconst SQUARED_DIFFERENCE = 'let resultTemp = (a - b) * (a - b);';\nconst SUB = 'let resultTemp = a - b;';\nexport function getBinaryOpString(type, useVec4) {\n  let doOpSnippet;\n  // Ops with NaN check\n  do {\n    switch (type) {\n      case BinaryOpType.ATAN2:\n        doOpSnippet = ATAN2;\n        break;\n      case BinaryOpType.MAX:\n        doOpSnippet = MAX;\n        break;\n      case BinaryOpType.MIN:\n        doOpSnippet = MIN;\n        break;\n      case BinaryOpType.MOD:\n        doOpSnippet = useVec4 ? MOD_VEC4 : MOD;\n        break;\n      case BinaryOpType.NOT_EQUAL:\n        doOpSnippet = useVec4 ? NOT_EQUAL_VEC4 : NOT_EQUAL;\n        break;\n      case BinaryOpType.POW:\n        doOpSnippet = useVec4 ? POW_VEC4 : POW;\n        break;\n      default:\n        continue;\n    }\n    let isNaN;\n    let dTypeN;\n    let boolN;\n    if (useVec4) {\n      isNaN = 'isnanVec4';\n      dTypeN = 'vec4<f32>';\n      boolN = 'vec4<bool>';\n    } else {\n      isNaN = 'isnan';\n      dTypeN = 'f32';\n      boolN = 'bool';\n    }\n    return `\n      let aIsNaN = ${isNaN}(a);\n      let aPostLegalization = select(a, ${dTypeN}(42), aIsNaN);\n      let bIsNaN = ${isNaN}(b);\n      let bPostLegalization = select(b, ${dTypeN}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${doOpSnippet}\n        return select(\n            resultTemp, ${dTypeN}(valueForNaN),\n            ${boolN}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `;\n  } while (false);\n  // Ops without NaN check\n  switch (type) {\n    case BinaryOpType.ADD:\n      doOpSnippet = ADD;\n      break;\n    case BinaryOpType.COMPLEX_MULTIPLY_IMAG:\n      doOpSnippet = COMPLEX_MULTIPLY_IMAG;\n      break;\n    case BinaryOpType.COMPLEX_MULTIPLY_REAL:\n      doOpSnippet = COMPLEX_MULTIPLY_REAL;\n      break;\n    case BinaryOpType.DIV:\n      doOpSnippet = DIV;\n      break;\n    case BinaryOpType.ELU_DER:\n      doOpSnippet = ELU_DER;\n      break;\n    case BinaryOpType.EQUAL:\n      doOpSnippet = EQUAL;\n      break;\n    case BinaryOpType.FLOOR_DIV:\n      doOpSnippet = FLOOR_DIV;\n      break;\n    case BinaryOpType.GREATER:\n      doOpSnippet = GREATER;\n      break;\n    case BinaryOpType.GREATER_EQUAL:\n      doOpSnippet = GREATER_EQUAL;\n      break;\n    case BinaryOpType.LESS:\n      doOpSnippet = LESS;\n      break;\n    case BinaryOpType.LESS_EQUAL:\n      doOpSnippet = LESS_EQUAL;\n      break;\n    case BinaryOpType.LOGICAL_AND:\n      return useVec4 ? LOGICAL_AND_VEC4 : LOGICAL_AND;\n    case BinaryOpType.LOGICAL_OR:\n      return useVec4 ? LOGICAL_OR_VEC4 : LOGICAL_OR;\n    case BinaryOpType.MUL:\n      doOpSnippet = MUL;\n      break;\n    case BinaryOpType.PRELU:\n      return useVec4 ? PRELU_VEC4 : PRELU;\n    case BinaryOpType.SQUARED_DIFFERENCE:\n      doOpSnippet = SQUARED_DIFFERENCE;\n      break;\n    case BinaryOpType.SUB:\n      doOpSnippet = SUB;\n      break;\n    default:\n    // throw new Error(`BinaryType ${type} is not implemented!`);\n  }\n  return `\n    ${doOpSnippet}\n    return resultTemp;\n  `;\n}","map":{"version":3,"names":["BinaryOpType","ADD","ATAN2","COMPLEX_MULTIPLY_REAL","COMPLEX_MULTIPLY_IMAG","DIV","ELU_DER","EQUAL","FLOOR_DIV","GREATER","GREATER_EQUAL","LESS","LESS_EQUAL","LOGICAL_AND","LOGICAL_AND_VEC4","LOGICAL_OR","LOGICAL_OR_VEC4","MAX","MIN","MOD","MOD_VEC4","MUL","NOT_EQUAL","NOT_EQUAL_VEC4","POW","POW_VEC4","PRELU","PRELU_VEC4","SQUARED_DIFFERENCE","SUB","getBinaryOpString","type","useVec4","doOpSnippet","isNaN","dTypeN","boolN"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/binary_op_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum BinaryOpType {\n  ADD,\n  ATAN2,\n  COMPLEX_MULTIPLY_IMAG,\n  COMPLEX_MULTIPLY_REAL,\n  DIV,\n  ELU_DER,\n  EQUAL,\n  FLOOR_DIV,\n  GREATER,\n  GREATER_EQUAL,\n  LESS,\n  LESS_EQUAL,\n  LOGICAL_AND,\n  LOGICAL_OR,\n  MAX,\n  MIN,\n  MOD,\n  MUL,\n  NOT_EQUAL,\n  POW,\n  PRELU,\n  SQUARED_DIFFERENCE,\n  SUB\n}\n\nconst ADD = 'let resultTemp = a + b;';\nconst ATAN2 = 'let resultTemp = atan2(a, b);';\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nconst COMPLEX_MULTIPLY_REAL = 'let resultTemp = areal * breal - aimag * bimag;';\nconst COMPLEX_MULTIPLY_IMAG = 'let resultTemp = areal * bimag + aimag * breal;';\nconst DIV = 'let resultTemp = a / b;';\nconst ELU_DER = 'let resultTemp = select(a * (b + 1.0), a, b >= b - b);';\nconst EQUAL = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n`;\nconst FLOOR_DIV = `\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n`;\nconst GREATER = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n`;\nconst GREATER_EQUAL = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n`;\nconst LESS = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n`;\nconst LESS_EQUAL = `\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n`;\nconst LOGICAL_AND = 'return f32(a >= 1.0 && b >= 1.0);';\nconst LOGICAL_AND_VEC4 = `return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));`;\nconst LOGICAL_OR = 'return f32(a >= 1.0 || b >= 1.0);';\nconst LOGICAL_OR_VEC4 = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`;\nconst MAX = 'let resultTemp = max(a, b);';\nconst MIN = 'let resultTemp = min(a, b);';\nconst MOD = `\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n`;\nconst MOD_VEC4 = `\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n`;\nconst MUL = 'let resultTemp = a * b;';\nconst NOT_EQUAL = `\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n`;\nconst NOT_EQUAL_VEC4 = `\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n`;\n\nconst POW = `\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n`;\nconst POW_VEC4 = `\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n`;\n\nconst PRELU = `if (a < 0.0) { return b * a; }  return a;`;\nconst PRELU_VEC4 = `\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n`;\nconst SQUARED_DIFFERENCE = 'let resultTemp = (a - b) * (a - b);';\nconst SUB = 'let resultTemp = a - b;';\n\nexport function getBinaryOpString(\n    type: BinaryOpType, useVec4?: boolean): string {\n  let doOpSnippet: string;\n\n  // Ops with NaN check\n  do {\n    switch (type) {\n      case BinaryOpType.ATAN2:\n        doOpSnippet = ATAN2;\n        break;\n      case BinaryOpType.MAX:\n        doOpSnippet = MAX;\n        break;\n      case BinaryOpType.MIN:\n        doOpSnippet = MIN;\n        break;\n      case BinaryOpType.MOD:\n        doOpSnippet = useVec4 ? MOD_VEC4 : MOD;\n        break;\n      case BinaryOpType.NOT_EQUAL:\n        doOpSnippet = useVec4 ? NOT_EQUAL_VEC4 : NOT_EQUAL;\n        break;\n      case BinaryOpType.POW:\n        doOpSnippet = useVec4 ? POW_VEC4 : POW;\n        break;\n      default:\n        continue;\n    }\n\n    let isNaN: string;\n    let dTypeN: string;\n    let boolN: string;\n    if (useVec4) {\n      isNaN = 'isnanVec4';\n      dTypeN = 'vec4<f32>';\n      boolN = 'vec4<bool>';\n    } else {\n      isNaN = 'isnan';\n      dTypeN = 'f32';\n      boolN = 'bool';\n    }\n\n    return `\n      let aIsNaN = ${isNaN}(a);\n      let aPostLegalization = select(a, ${dTypeN}(42), aIsNaN);\n      let bIsNaN = ${isNaN}(b);\n      let bPostLegalization = select(b, ${dTypeN}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${doOpSnippet}\n        return select(\n            resultTemp, ${dTypeN}(valueForNaN),\n            ${boolN}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `;\n  } while (false);\n\n  // Ops without NaN check\n  switch (type) {\n    case BinaryOpType.ADD:\n      doOpSnippet = ADD;\n      break;\n    case BinaryOpType.COMPLEX_MULTIPLY_IMAG:\n      doOpSnippet = COMPLEX_MULTIPLY_IMAG;\n      break;\n    case BinaryOpType.COMPLEX_MULTIPLY_REAL:\n      doOpSnippet = COMPLEX_MULTIPLY_REAL;\n      break;\n    case BinaryOpType.DIV:\n      doOpSnippet = DIV;\n      break;\n    case BinaryOpType.ELU_DER:\n      doOpSnippet = ELU_DER;\n      break;\n    case BinaryOpType.EQUAL:\n      doOpSnippet = EQUAL;\n      break;\n    case BinaryOpType.FLOOR_DIV:\n      doOpSnippet = FLOOR_DIV;\n      break;\n    case BinaryOpType.GREATER:\n      doOpSnippet = GREATER;\n      break;\n    case BinaryOpType.GREATER_EQUAL:\n      doOpSnippet = GREATER_EQUAL;\n      break;\n    case BinaryOpType.LESS:\n      doOpSnippet = LESS;\n      break;\n    case BinaryOpType.LESS_EQUAL:\n      doOpSnippet = LESS_EQUAL;\n      break;\n    case BinaryOpType.LOGICAL_AND:\n      return useVec4 ? LOGICAL_AND_VEC4 : LOGICAL_AND;\n    case BinaryOpType.LOGICAL_OR:\n      return useVec4 ? LOGICAL_OR_VEC4 : LOGICAL_OR;\n    case BinaryOpType.MUL:\n      doOpSnippet = MUL;\n      break;\n    case BinaryOpType.PRELU:\n      return useVec4 ? PRELU_VEC4 : PRELU;\n    case BinaryOpType.SQUARED_DIFFERENCE:\n      doOpSnippet = SQUARED_DIFFERENCE;\n      break;\n    case BinaryOpType.SUB:\n      doOpSnippet = SUB;\n      break;\n    default:\n      // throw new Error(`BinaryType ${type} is not implemented!`);\n  }\n  return `\n    ${doOpSnippet}\n    return resultTemp;\n  `;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}