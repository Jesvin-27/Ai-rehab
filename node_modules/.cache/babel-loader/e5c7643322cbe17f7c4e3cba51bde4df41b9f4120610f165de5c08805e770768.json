{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class CropAndResizeProgram {\n  constructor(channnel, boxShape, cropSize, method) {\n    this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n    this.uniforms = 'extrapolationValue : f32,';\n    this.workgroupSize = [64, 1, 1];\n    this.size = true;\n    const [numBoxes] = boxShape;\n    this.outputShape = [numBoxes, cropSize[0], cropSize[1], channnel];\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.methodId = method === 'bilinear' ? 1 : 0;\n    this.cropHeightBiggerThan1 = this.outputShape[1] > 1;\n    this.cropWidthBiggerThan1 = this.outputShape[2] > 1;\n    this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;\n  }\n  getUserCode() {\n    const [inputHeightFloat, inputWidthFloat] = [`f32(uniforms.imageShape[1] - 1)`, `f32(uniforms.imageShape[2] - 1)`];\n    const [heightRatio, heightScale, inY] = this.cropHeightBiggerThan1 ? [`(${inputHeightFloat} / f32(uniforms.outShape[1] - 1))`, '(y2-y1) * height_ratio', `y1*${inputHeightFloat} + f32(y)*(height_scale)`] : ['0.0', '0.0', `0.5 * (y1+y2) * ${inputHeightFloat}`];\n    const [widthRatio, widthScale, inX] = this.cropWidthBiggerThan1 ? [`(${inputWidthFloat} / f32(uniforms.outShape[2] - 1))`, '(x2-x1) * width_ratio', `x1*${inputWidthFloat} + f32(x)*(width_scale)`] : ['0.0', '0.0', `0.5 * (x1+x2) * ${inputWidthFloat}`];\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${heightRatio});\n        let width_ratio = f32(${widthRatio});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${heightScale};\n        let width_scale = ${widthScale};\n        let in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["getMainHeaderString","main","computeDispatch","flatDispatchLayout","CropAndResizeProgram","constructor","channnel","boxShape","cropSize","method","variableNames","uniforms","workgroupSize","size","numBoxes","outputShape","dispatchLayout","dispatch","methodId","cropHeightBiggerThan1","cropWidthBiggerThan1","shaderKey","getUserCode","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","userCode"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/crop_and_resize_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class CropAndResizeProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  uniforms = 'extrapolationValue : f32,';\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  methodId: number;\n  cropHeightBiggerThan1: boolean;\n  cropWidthBiggerThan1: boolean;\n  size = true;\n\n  constructor(\n      channnel: number, boxShape: [number, number], cropSize: [number, number],\n      method: 'bilinear'|'nearest') {\n    const [numBoxes, ] = boxShape;\n    this.outputShape = [numBoxes, cropSize[0], cropSize[1], channnel];\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    this.methodId = method === 'bilinear' ? 1 : 0;\n    this.cropHeightBiggerThan1 = this.outputShape[1] > 1;\n    this.cropWidthBiggerThan1 = this.outputShape[2] > 1;\n    this.shaderKey = `cropAndResize_${this.methodId}_${\n        this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;\n  }\n\n  getUserCode(): string {\n    const [inputHeightFloat, inputWidthFloat] =\n        [`f32(uniforms.imageShape[1] - 1)`, `f32(uniforms.imageShape[2] - 1)`];\n\n    const [heightRatio, heightScale, inY] = this.cropHeightBiggerThan1 ?\n        [\n          `(${inputHeightFloat} / f32(uniforms.outShape[1] - 1))`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + f32(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = this.cropWidthBiggerThan1 ?\n        [\n          `(${inputWidthFloat} / f32(uniforms.outShape[2] - 1))`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + f32(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${heightRatio});\n        let width_ratio = f32(${widthRatio});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${heightScale};\n        let width_scale = ${widthScale};\n        let in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AAC3E,SAAQC,eAAe,EAAEC,kBAAkB,QAAO,eAAe;AAEjE,OAAM,MAAOC,oBAAoB;EAa/BC,YACIC,QAAgB,EAAEC,QAA0B,EAAEC,QAA0B,EACxEC,MAA4B;IAVhC,KAAAC,aAAa,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC;IAC5C,KAAAC,QAAQ,GAAG,2BAA2B;IACtC,KAAAC,aAAa,GAA6B,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IAIpD,KAAAC,IAAI,GAAG,IAAI;IAKT,MAAM,CAACC,QAAQ,CAAG,GAAGP,QAAQ;IAC7B,IAAI,CAACQ,WAAW,GAAG,CAACD,QAAQ,EAAEN,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,EAAEF,QAAQ,CAAC;IACjE,IAAI,CAACU,cAAc,GAAGb,kBAAkB,CAAC,IAAI,CAACY,WAAW,CAAC;IAC1D,IAAI,CAACE,QAAQ,GAAGf,eAAe,CAC3B,IAAI,CAACc,cAAc,EAAE,IAAI,CAACD,WAAW,EAAE,IAAI,CAACH,aAAa,CAAC;IAE9D,IAAI,CAACM,QAAQ,GAAGT,MAAM,KAAK,UAAU,GAAG,CAAC,GAAG,CAAC;IAC7C,IAAI,CAACU,qBAAqB,GAAG,IAAI,CAACJ,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC;IACpD,IAAI,CAACK,oBAAoB,GAAG,IAAI,CAACL,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC;IACnD,IAAI,CAACM,SAAS,GAAG,iBAAiB,IAAI,CAACH,QAAQ,IAC3C,IAAI,CAACC,qBAAqB,IAAI,IAAI,CAACC,oBAAoB,EAAE;EAC/D;EAEAE,WAAWA,CAAA;IACT,MAAM,CAACC,gBAAgB,EAAEC,eAAe,CAAC,GACrC,CAAC,iCAAiC,EAAE,iCAAiC,CAAC;IAE1E,MAAM,CAACC,WAAW,EAAEC,WAAW,EAAEC,GAAG,CAAC,GAAG,IAAI,CAACR,qBAAqB,GAC9D,CACE,IAAII,gBAAgB,mCAAmC,EACvD,wBAAwB,EACxB,MAAMA,gBAAgB,0BAA0B,CACjD,GACD,CACE,KAAK,EACL,KAAK,EACL,mBAAmBA,gBAAgB,EAAE,CACtC;IACL,MAAM,CAACK,UAAU,EAAEC,UAAU,EAAEC,GAAG,CAAC,GAAG,IAAI,CAACV,oBAAoB,GAC3D,CACE,IAAII,eAAe,mCAAmC,EACtD,uBAAuB,EACvB,MAAMA,eAAe,yBAAyB,CAC/C,GACD,CACE,KAAK,EACL,KAAK,EACL,mBAAmBA,eAAe,EAAE,CACrC;IAEL;IACA;IACA;IACA,MAAMO,QAAQ,GAAG;MACf9B,IAAI,CAAC,OAAO,CAAC;;;iCAGcwB,WAAW;gCACZG,UAAU;;;;;;;;;;;;;;;6BAebF,WAAW;4BACZG,UAAU;qBACjBF,GAAG;mCACWJ,gBAAgB;;;;qBAI9BO,GAAG;mCACWN,eAAe;;;;;aAKrC,IAAI,CAACN,QAAQ;;;;;;;;;;;;;;;;;;;;;;;KAuBrB;IACD,OAAOa,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}