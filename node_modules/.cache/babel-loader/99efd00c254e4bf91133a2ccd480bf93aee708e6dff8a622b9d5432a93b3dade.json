{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { fill } from '../kernels/Fill';\nimport { SparseSegmentIdCountProgram, SparseSegmentMeanProgram, SparseSegmentSumProgram } from '../sparse_segment_reduce_webgpu';\nexport function sparseSegmentReduce(input, indices, segmentIds, isSum = false, backend) {\n  const inputSize = util.sizeFromShape(input.shape);\n  const segmentSize = inputSize / input.shape[0];\n  const dtype = input.dtype;\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const numIndices = util.sizeFromShape(indices.shape);\n  const $segmentIds = backend.readSync(segmentIds.dataId);\n  const lastSegmentIdPlusOne = numIndices > 0 ? $segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n  let program;\n  const outputShape = input.shape.slice();\n  outputShape[0] = outputRows;\n  const sparseSize = numIndices * segmentSize;\n  const sparseSegmentSum = fill({\n    backend,\n    attrs: {\n      shape: outputShape,\n      value: 0,\n      dtype\n    }\n  });\n  program = new SparseSegmentSumProgram(outputShape, sparseSize, dtype);\n  let uniformData = [{\n    type: 'int32',\n    data: [segmentSize]\n  }, {\n    type: 'int32',\n    data: [sparseSize]\n  }];\n  const $sparseSegmentSum = backend.runWebGPUProgram(program, [input, indices, segmentIds], dtype, uniformData, sparseSegmentSum);\n  if (isSum) {\n    return $sparseSegmentSum;\n  }\n  const sparseSegmentIdCount = fill({\n    backend,\n    attrs: {\n      shape: [outputRows],\n      value: 0,\n      dtype: 'int32'\n    }\n  });\n  program = new SparseSegmentIdCountProgram(outputRows, segmentIds.shape);\n  const $sparseSegmentIdCount = backend.runWebGPUProgram(program, [segmentIds], 'int32', null, sparseSegmentIdCount);\n  const sparseSegmentMean = fill({\n    backend,\n    attrs: {\n      shape: outputShape,\n      value: 0,\n      dtype\n    }\n  });\n  program = new SparseSegmentMeanProgram(outputShape, dtype);\n  uniformData = [{\n    type: 'int32',\n    data: [segmentSize]\n  }];\n  const $sparseSegmentMean = backend.runWebGPUProgram(program, [$sparseSegmentSum, $sparseSegmentIdCount], dtype, uniformData, sparseSegmentMean);\n  backend.disposeData($sparseSegmentSum.dataId);\n  backend.disposeData($sparseSegmentIdCount.dataId);\n  return $sparseSegmentMean;\n}","map":{"version":3,"names":["util","fill","SparseSegmentIdCountProgram","SparseSegmentMeanProgram","SparseSegmentSumProgram","sparseSegmentReduce","input","indices","segmentIds","isSum","backend","inputSize","sizeFromShape","shape","segmentSize","dtype","numIndices","$segmentIds","readSync","dataId","lastSegmentIdPlusOne","outputRows","program","outputShape","slice","sparseSize","sparseSegmentSum","attrs","value","uniformData","type","data","$sparseSegmentSum","runWebGPUProgram","sparseSegmentIdCount","$sparseSegmentIdCount","sparseSegmentMean","$sparseSegmentMean","disposeData"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/kernel_utils/sparse_segment_reduce.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {fill} from '../kernels/Fill';\nimport {SparseSegmentIdCountProgram, SparseSegmentMeanProgram, SparseSegmentSumProgram} from '../sparse_segment_reduce_webgpu';\nimport {WebGPUProgram} from '../webgpu_program';\n\nexport function sparseSegmentReduce(\n    input: TensorInfo, indices: TensorInfo, segmentIds: TensorInfo,\n    isSum = false, backend: WebGPUBackend): TensorInfo {\n  const inputSize = util.sizeFromShape(input.shape);\n  const segmentSize = inputSize / input.shape[0];\n  const dtype = input.dtype;\n\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const numIndices = util.sizeFromShape(indices.shape);\n  const $segmentIds = backend.readSync(segmentIds.dataId) as TypedArray;\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? $segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  let program: WebGPUProgram;\n  const outputShape = input.shape.slice();\n  outputShape[0] = outputRows;\n\n  const sparseSize = numIndices * segmentSize;\n  const sparseSegmentSum =\n      fill({backend, attrs: {shape: outputShape, value: 0, dtype}});\n  program = new SparseSegmentSumProgram(outputShape, sparseSize, dtype);\n  let uniformData = [\n    {type: 'int32', data: [segmentSize]}, {type: 'int32', data: [sparseSize]}\n  ];\n  const $sparseSegmentSum = backend.runWebGPUProgram(\n      program, [input, indices, segmentIds], dtype, uniformData,\n      sparseSegmentSum);\n\n  if (isSum) {\n    return $sparseSegmentSum;\n  }\n\n  const sparseSegmentIdCount =\n      fill({backend, attrs: {shape: [outputRows], value: 0, dtype: 'int32'}});\n  program = new SparseSegmentIdCountProgram(outputRows, segmentIds.shape);\n  const $sparseSegmentIdCount = backend.runWebGPUProgram(\n      program, [segmentIds], 'int32', null, sparseSegmentIdCount);\n\n  const sparseSegmentMean =\n      fill({backend, attrs: {shape: outputShape, value: 0, dtype}});\n  program = new SparseSegmentMeanProgram(outputShape, dtype);\n  uniformData = [{type: 'int32', data: [segmentSize]}];\n  const $sparseSegmentMean = backend.runWebGPUProgram(\n      program, [$sparseSegmentSum, $sparseSegmentIdCount], dtype, uniformData,\n      sparseSegmentMean);\n\n  backend.disposeData($sparseSegmentSum.dataId);\n  backend.disposeData($sparseSegmentIdCount.dataId);\n  return $sparseSegmentMean;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}