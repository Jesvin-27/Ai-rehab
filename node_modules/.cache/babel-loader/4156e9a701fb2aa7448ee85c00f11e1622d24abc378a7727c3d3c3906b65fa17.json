{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { atomicAddSnippet } from './shader_util';\nimport { dataTypeToGPUType, getCoordsDataType, getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class ScatterProgram {\n  constructor(flattenXShape, sliceDim, indicesRank, updatesRank, strides, shape, outputDtype, sumDupeIndices = true) {\n    this.variableNames = ['updates', 'indices'];\n    this.workgroupSize = [64, 1, 1];\n    this.atomic = true;\n    this.outputShape = shape;\n    this.type = outputDtype;\n    this.sumDupeIndices = sumDupeIndices;\n    this.dispatchLayout = flatDispatchLayout(flattenXShape);\n    // Dispatching based on |updates| shape instead of output shape.\n    this.dispatch = computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);\n    this.sliceDimGreaterThanOne = sliceDim > 1;\n    this.shaderKey = `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${outputDtype}_${sumDupeIndices}_${strides.length}`;\n    const stridesType = getCoordsDataType(strides.length);\n    this.uniforms = `sliceDim : i32, strides: ${stridesType}, updatesSize: i32,`;\n    this.updatesRank = updatesRank;\n    this.indicesRank = indicesRank;\n  }\n  getUserCode() {\n    let indicesString = '';\n    if (this.indicesRank === 1) {\n      indicesString = 'coords[0]';\n    } else if (this.indicesRank === 2) {\n      indicesString = 'coords[0], j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n    const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' : 'uniforms.strides';\n    let outCoordsString = '';\n    let getUpdatesCoordsFromFlatIndex = '';\n    if (this.dispatchLayout.x.length === 1) {\n      outCoordsString = 'flattenedIndex';\n      getUpdatesCoordsFromFlatIndex = `\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      `;\n    } else if (this.dispatchLayout.x.length === 2) {\n      outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';\n      getUpdatesCoordsFromFlatIndex = `\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      `;\n    }\n    const updatesString = Array.from({\n      length: this.updatesRank\n    }, (_, idx) => `coords[${idx}]`);\n    const updatesSnippet = `getUpdates(${updatesString.join(', ')})`;\n    const userCode = `\n    ${getUpdatesCoordsFromFlatIndex}\n      ${main('index')} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${indicesSnippet}));\n            flattenedIndex = flattenedIndex + indexInside * ${strideString};\n          }\n          let updateValue =\n              ${dataTypeToGPUType(this.type)}(${updatesSnippet});\n          let flatIndex = getOutputIndexFromCoords(${outCoordsString});\n\n          ${this.sumDupeIndices ? atomicAddSnippet('&result[flatIndex]', 'updateValue', this.type) : `atomicStore(&result[flatIndex], bitcast<i32>(updateValue));`}\n        }\n      }`;\n    return userCode;\n  }\n}","map":{"version":3,"names":["atomicAddSnippet","dataTypeToGPUType","getCoordsDataType","getMainHeaderString","main","computeDispatch","flatDispatchLayout","ScatterProgram","constructor","flattenXShape","sliceDim","indicesRank","updatesRank","strides","shape","outputDtype","sumDupeIndices","variableNames","workgroupSize","atomic","outputShape","type","dispatchLayout","dispatch","sliceDimGreaterThanOne","shaderKey","length","stridesType","uniforms","getUserCode","indicesString","indicesSnippet","strideString","outCoordsString","getUpdatesCoordsFromFlatIndex","x","updatesString","Array","from","_","idx","updatesSnippet","join","userCode"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/scatter_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType} from '@tensorflow/tfjs-core';\n\nimport {atomicAddSnippet} from './shader_util';\nimport {dataTypeToGPUType, getCoordsDataType, getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class ScatterProgram implements WebGPUProgram {\n  variableNames = ['updates', 'indices'];\n  uniforms: string;\n  outputShape: number[];\n  sumDupeIndices: boolean;\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  updatesRank: number;\n  indicesRank: number;\n  sliceDimGreaterThanOne: boolean;\n  atomic = true;\n  type: DataType;\n\n  constructor(\n      flattenXShape: number[], sliceDim: number, indicesRank: number,\n      updatesRank: number, strides: number[], shape: number[],\n      outputDtype: DataType, sumDupeIndices = true) {\n    this.outputShape = shape;\n    this.type = outputDtype;\n    this.sumDupeIndices = sumDupeIndices;\n    this.dispatchLayout = flatDispatchLayout(flattenXShape);\n    // Dispatching based on |updates| shape instead of output shape.\n    this.dispatch =\n        computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);\n    this.sliceDimGreaterThanOne = sliceDim > 1;\n    this.shaderKey =\n        `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${\n            outputDtype}_${sumDupeIndices}_${strides.length}`;\n    const stridesType = getCoordsDataType(strides.length);\n    this.uniforms =\n        `sliceDim : i32, strides: ${stridesType}, updatesSize: i32,`;\n    this.updatesRank = updatesRank;\n    this.indicesRank = indicesRank;\n  }\n\n  getUserCode(): string {\n    let indicesString = '';\n    if (this.indicesRank === 1) {\n      indicesString = 'coords[0]';\n    } else if (this.indicesRank === 2) {\n      indicesString = 'coords[0], j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n\n    const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' :\n                                                       'uniforms.strides';\n\n    let outCoordsString = '';\n    let getUpdatesCoordsFromFlatIndex = '';\n    if (this.dispatchLayout.x.length === 1) {\n      outCoordsString = 'flattenedIndex';\n      getUpdatesCoordsFromFlatIndex = `\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      `;\n    } else if (this.dispatchLayout.x.length === 2) {\n      outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';\n      getUpdatesCoordsFromFlatIndex = `\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      `;\n    }\n    const updatesString =\n        Array.from({length: this.updatesRank}, (_, idx) => `coords[${idx}]`);\n    const updatesSnippet = `getUpdates(${updatesString.join(', ')})`;\n\n    const userCode = `\n    ${getUpdatesCoordsFromFlatIndex}\n      ${main('index')} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${indicesSnippet}));\n            flattenedIndex = flattenedIndex + indexInside * ${strideString};\n          }\n          let updateValue =\n              ${dataTypeToGPUType(this.type)}(${updatesSnippet});\n          let flatIndex = getOutputIndexFromCoords(${outCoordsString});\n\n          ${\n        this.sumDupeIndices ?\n            atomicAddSnippet(\n                '&result[flatIndex]', 'updateValue',\n                this.type as 'float32' | 'int32') :\n            `atomicStore(&result[flatIndex], bitcast<i32>(updateValue));`}\n        }\n      }`;\n    return userCode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}