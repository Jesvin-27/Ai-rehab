{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { getCoordsXYZ, getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class ArgMinMaxProgram {\n  constructor(inputShape, axis, reduceType) {\n    this.workgroupSize = [64, 1, 1];\n    this.variableNames = ['x'];\n    this.uniforms = 'infinityValue : f32,';\n    this.size = true;\n    const axes = [axis];\n    this.op = reduceType === 'min' ? '<' : '>';\n    // |outShape| is the shape with the removed axis\n    const [outputShape, reduceShape] = backend_util.computeOutAndReduceShapes(inputShape, axes);\n    this.outputShape = outputShape.length === 0 ? [1] : outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    // The shared algorithm is mainly used for large reduce size. It fully\n    // utilizes the threads in one workgroup to do the reduction. However,\n    // when the reduce size is very small, it's better to use the plain\n    // algorithm to reduce the number of workgroups to speedup. The threthold\n    // can be further tuned.\n    if (util.sizeFromShape(reduceShape) < 32) {\n      this.type = 'plain';\n      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    } else {\n      this.type = 'shared';\n      // A work group only outputs a data, so we transfer [1, 1, 1] to compute\n      // dispatch size.\n      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);\n    }\n    this.inputShape = inputShape;\n    this.shaderKey = `argMinMax_${this.op}_${this.type}`;\n  }\n  getUserCode() {\n    const workgroupSizeX = this.workgroupSize[0];\n    const getInputShapeLastDim = () => {\n      if (this.inputShape.length === 1) {\n        return 'uniforms.xShape';\n      } else {\n        return `uniforms.xShape.${getCoordsXYZ(this.inputShape.length - 1)}`;\n      }\n    };\n    const splitOutputCoords = () => {\n      let snippet = '';\n      if (this.outputShape.length === 1) {\n        if (this.inputShape.length !== 1) {\n          snippet += 'outputCoords,';\n        }\n      } else {\n        for (let i = 0; i < this.outputShape.length; i++) {\n          snippet += `outputCoords.${getCoordsXYZ(i)},`;\n        }\n      }\n      return snippet;\n    };\n    if (this.type === 'shared') {\n      const sharedMemorySnippet = `\n      var<workgroup> xBestIndices : array<i32, ${workgroupSizeX}>;\n      var<workgroup> xBestValues : array<f32, ${workgroupSizeX}>;\n    `;\n      const userCode = `\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${sharedMemorySnippet}\n\n      ${main('index')} {\n        let outputIndex = index / ${workgroupSizeX};\n        let reduceLength = ${getInputShapeLastDim()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${workgroupSizeX}) {\n          let candidate = getX(${splitOutputCoords()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${workgroupSizeX}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `;\n      return userCode;\n    } else {\n      const userCode = `\n      ${main('index')} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${splitOutputCoords()} 0);\n          let reduceLength = ${getInputShapeLastDim()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${splitOutputCoords()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `;\n      return userCode;\n    }\n  }\n}","map":{"version":3,"names":["backend_util","util","getCoordsXYZ","getMainHeaderString","main","computeDispatch","flatDispatchLayout","ArgMinMaxProgram","constructor","inputShape","axis","reduceType","workgroupSize","variableNames","uniforms","size","axes","op","outputShape","reduceShape","computeOutAndReduceShapes","length","dispatchLayout","sizeFromShape","type","dispatch","shaderKey","getUserCode","workgroupSizeX","getInputShapeLastDim","splitOutputCoords","snippet","i","sharedMemorySnippet","userCode"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/argminmax_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {getCoordsXYZ, getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class ArgMinMaxProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  variableNames = ['x'];\n  uniforms = 'infinityValue : f32,';\n  inputShape: number[];\n  reductionFactor: number;\n  op: string;\n  size = true;\n  private type: string;\n\n  constructor(inputShape: number[], axis: number, reduceType: 'min'|'max') {\n    const axes = [axis];\n\n    this.op = reduceType === 'min' ? '<' : '>';\n\n    // |outShape| is the shape with the removed axis\n    const [outputShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(inputShape, axes);\n\n    this.outputShape = outputShape.length === 0 ? [1] : outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    // The shared algorithm is mainly used for large reduce size. It fully\n    // utilizes the threads in one workgroup to do the reduction. However,\n    // when the reduce size is very small, it's better to use the plain\n    // algorithm to reduce the number of workgroups to speedup. The threthold\n    // can be further tuned.\n    if (util.sizeFromShape(reduceShape) < 32) {\n      this.type = 'plain';\n      this.dispatch = computeDispatch(\n          this.dispatchLayout, this.outputShape, this.workgroupSize);\n    } else {\n      this.type = 'shared';\n      // A work group only outputs a data, so we transfer [1, 1, 1] to compute\n      // dispatch size.\n      this.dispatch =\n          computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);\n    }\n\n    this.inputShape = inputShape;\n    this.shaderKey = `argMinMax_${this.op}_${this.type}`;\n  }\n\n  getUserCode(): string {\n    const workgroupSizeX = this.workgroupSize[0];\n    const getInputShapeLastDim = () => {\n      if (this.inputShape.length === 1) {\n        return 'uniforms.xShape';\n      } else {\n        return `uniforms.xShape.${getCoordsXYZ(this.inputShape.length - 1)}`;\n      }\n    };\n\n    const splitOutputCoords = () => {\n      let snippet = '';\n      if (this.outputShape.length === 1) {\n        if (this.inputShape.length !== 1) {\n          snippet += 'outputCoords,';\n        }\n      } else {\n        for (let i = 0; i < this.outputShape.length; i++) {\n          snippet += `outputCoords.${getCoordsXYZ(i)},`;\n        }\n      }\n      return snippet;\n    };\n\n    if (this.type === 'shared') {\n      const sharedMemorySnippet = `\n      var<workgroup> xBestIndices : array<i32, ${workgroupSizeX}>;\n      var<workgroup> xBestValues : array<f32, ${workgroupSizeX}>;\n    `;\n      const userCode = `\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${sharedMemorySnippet}\n\n      ${main('index')} {\n        let outputIndex = index / ${workgroupSizeX};\n        let reduceLength = ${getInputShapeLastDim()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${workgroupSizeX}) {\n          let candidate = getX(${splitOutputCoords()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${workgroupSizeX}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `;\n      return userCode;\n    } else {\n      const userCode = `\n      ${main('index')} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${splitOutputCoords()} 0);\n          let reduceLength = ${getInputShapeLastDim()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${splitOutputCoords()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `;\n      return userCode;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}