{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { atomicAddSnippet } from './shader_util';\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nconst writeSnippet = `\n  fn bincount_write(index: i32, value: f32) {\n    ${atomicAddSnippet('&result[index]', 'value', 'float32')}\n  }\n`;\nconst binaryWriteSnippet = `\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n`;\nexport class BincountProgram {\n  constructor(shape, hasWeights, binaryOutput = false) {\n    this.outputShape = [];\n    this.variableNames = ['x'];\n    this.uniforms = 'binCountSize : i32,';\n    this.workgroupSize = [64, 1, 1];\n    this.atomic = true;\n    this.hasWeights = true;\n    this.binaryOutput = false;\n    this.outputShape = shape;\n    this.rank = shape.length;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.binaryOutput = binaryOutput;\n    if (binaryOutput) {\n      this.atomic = false;\n    }\n    this.hasWeights = hasWeights;\n    if (this.hasWeights) {\n      this.variableNames.push('w');\n    }\n    this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;\n  }\n  getUserCode() {\n    const userCode = `\n    ${this.binaryOutput ? binaryWriteSnippet : writeSnippet}\n  ${main('index')} {\n    ${this.rank === 1 ? `if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput ? 1. : this.hasWeights ? 'getW(index)' : '1.'};\n        bincount_write(indexVal, value);\n      }\n    }` : `let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput ? 1. : this.hasWeights ? 'getW(coord[0], coord[1])' : '1.'};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["atomicAddSnippet","getMainHeaderString","main","computeDispatch","flatDispatchLayout","writeSnippet","binaryWriteSnippet","BincountProgram","constructor","shape","hasWeights","binaryOutput","outputShape","variableNames","uniforms","workgroupSize","atomic","rank","length","dispatchLayout","dispatch","push","shaderKey","getUserCode","userCode"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/bincount_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {atomicAddSnippet} from './shader_util';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nconst writeSnippet = `\n  fn bincount_write(index: i32, value: f32) {\n    ${atomicAddSnippet('&result[index]', 'value', 'float32')}\n  }\n`;\n\nconst binaryWriteSnippet = `\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n`;\n\nexport class BincountProgram implements WebGPUProgram {\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'binCountSize : i32,';\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  atomic = true;\n  hasWeights = true;\n  binaryOutput = false;\n  rank: number;\n\n  constructor(\n      shape: [number]|[number, number], hasWeights: boolean,\n      binaryOutput = false) {\n    this.outputShape = shape;\n    this.rank = shape.length;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    this.binaryOutput = binaryOutput;\n    if (binaryOutput) {\n      this.atomic = false;\n    }\n    this.hasWeights = hasWeights;\n    if (this.hasWeights) {\n      this.variableNames.push('w');\n    }\n    this.shaderKey =\n        `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    ${this.binaryOutput ? binaryWriteSnippet : writeSnippet}\n  ${main('index')} {\n    ${\n        this.rank === 1 ?\n            `if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${\n                this.binaryOutput ? 1. :\n                                    (this.hasWeights ? 'getW(index)' : '1.')};\n        bincount_write(indexVal, value);\n      }\n    }` :\n            `let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${\n                this.binaryOutput ?\n                    1. :\n                    (this.hasWeights ? 'getW(coord[0], coord[1])' : '1.')};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,gBAAgB,QAAO,eAAe;AAC9C,SAAQC,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AAC3E,SAAQC,eAAe,EAAEC,kBAAkB,QAAO,eAAe;AAEjE,MAAMC,YAAY,GAAG;;MAEfL,gBAAgB,CAAC,gBAAgB,EAAE,OAAO,EAAE,SAAS,CAAC;;CAE3D;AAED,MAAMM,kBAAkB,GAAG;;;;CAI1B;AAED,OAAM,MAAOC,eAAe;EAa1BC,YACIC,KAAgC,EAAEC,UAAmB,EACrDC,YAAY,GAAG,KAAK;IAdxB,KAAAC,WAAW,GAAa,EAAE;IAI1B,KAAAC,aAAa,GAAG,CAAC,GAAG,CAAC;IACrB,KAAAC,QAAQ,GAAG,qBAAqB;IAChC,KAAAC,aAAa,GAA6B,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACpD,KAAAC,MAAM,GAAG,IAAI;IACb,KAAAN,UAAU,GAAG,IAAI;IACjB,KAAAC,YAAY,GAAG,KAAK;IAMlB,IAAI,CAACC,WAAW,GAAGH,KAAK;IACxB,IAAI,CAACQ,IAAI,GAAGR,KAAK,CAACS,MAAM;IACxB,IAAI,CAACC,cAAc,GAAGf,kBAAkB,CAAC,IAAI,CAACQ,WAAW,CAAC;IAC1D,IAAI,CAACQ,QAAQ,GAAGjB,eAAe,CAC3B,IAAI,CAACgB,cAAc,EAAE,IAAI,CAACP,WAAW,EAAE,IAAI,CAACG,aAAa,CAAC;IAE9D,IAAI,CAACJ,YAAY,GAAGA,YAAY;IAChC,IAAIA,YAAY,EAAE;MAChB,IAAI,CAACK,MAAM,GAAG,KAAK;;IAErB,IAAI,CAACN,UAAU,GAAGA,UAAU;IAC5B,IAAI,IAAI,CAACA,UAAU,EAAE;MACnB,IAAI,CAACG,aAAa,CAACQ,IAAI,CAAC,GAAG,CAAC;;IAE9B,IAAI,CAACC,SAAS,GACV,YAAY,IAAI,CAACZ,UAAU,IAAI,IAAI,CAACC,YAAY,IAAI,IAAI,CAACM,IAAI,EAAE;EACrE;EAEAM,WAAWA,CAAA;IACT,MAAMC,QAAQ,GAAG;MACf,IAAI,CAACb,YAAY,GAAGL,kBAAkB,GAAGD,YAAY;IACvDH,IAAI,CAAC,OAAO,CAAC;MAET,IAAI,CAACe,IAAI,KAAK,CAAC,GACX;;;sBAII,IAAI,CAACN,YAAY,GAAG,EAAE,GACD,IAAI,CAACD,UAAU,GAAG,aAAa,GAAG,IAAK;;;MAGtE,GACM;;;;sBAKI,IAAI,CAACC,YAAY,GACb,EAAE,GACD,IAAI,CAACD,UAAU,GAAG,0BAA0B,GAAG,IAAK;;;MAGnE;;GAEH;IACC,OAAOc,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}