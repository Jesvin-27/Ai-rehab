{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use backend file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { FromPixels, util } from '@tensorflow/tfjs-core';\nimport { FromPixelsProgram } from '../from_pixels_webgpu';\nexport const fromPixelsConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgpu',\n  kernelFunc: fromPixels\n};\nlet fromPixels2DContext;\nlet willReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\nexport function fromPixels(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  let {\n    pixels\n  } = inputs;\n  const {\n    numChannels\n  } = attrs;\n  if (pixels == null) {\n    throw new Error('pixels passed to tf.browser.fromPixels() can not be null');\n  }\n  const isVideo = typeof HTMLVideoElement !== 'undefined' && pixels instanceof HTMLVideoElement;\n  const isImage = typeof HTMLImageElement !== 'undefined' && pixels instanceof HTMLImageElement;\n  const isCanvas = typeof HTMLCanvasElement !== 'undefined' && pixels instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && pixels instanceof OffscreenCanvas;\n  const isImageBitmap = typeof ImageBitmap !== 'undefined' && pixels instanceof ImageBitmap;\n  const [width, height] = isVideo ? [pixels.videoWidth, pixels.videoHeight] : [pixels.width, pixels.height];\n  const outputShape = [height, width, numChannels];\n  const importVideo = env().getBool('WEBGPU_IMPORT_EXTERNAL_TEXTURE') && isVideo;\n  const isVideoOrImage = isVideo || isImage;\n  if (isImageBitmap || isCanvas || isVideoOrImage) {\n    let resource;\n    if (importVideo) {\n      resource = backend.device.importExternalTexture({\n        source: pixels\n      });\n    } else {\n      if (isVideoOrImage) {\n        const newWillReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n        if (fromPixels2DContext == null || newWillReadFrequently !== willReadFrequently) {\n          willReadFrequently = newWillReadFrequently;\n          fromPixels2DContext = document.createElement('canvas').getContext('2d', {\n            willReadFrequently\n          });\n        }\n        fromPixels2DContext.canvas.width = width;\n        fromPixels2DContext.canvas.height = height;\n        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);\n        pixels = fromPixels2DContext.canvas;\n      }\n      const usage = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING;\n      const format = 'rgba8unorm';\n      const texture = backend.textureManager.acquireTexture(outputShape[1], outputShape[0], format, usage);\n      backend.queue.copyExternalImageToTexture({\n        source: pixels\n      }, {\n        texture\n      }, [outputShape[1], outputShape[0]]);\n      resource = texture;\n    }\n    const size = util.sizeFromShape(outputShape);\n    const strides = util.computeStrides(outputShape);\n    const program = new FromPixelsProgram(outputShape, numChannels, importVideo);\n    const uniformData = [{\n      type: 'uint32',\n      data: [size]\n    }, {\n      type: 'uint32',\n      data: [numChannels]\n    }, {\n      type: 'uint32',\n      data: [...strides]\n    }];\n    const input = backend.makeTensorInfo([height, width], 'int32');\n    const info = backend.tensorMap.get(input.dataId);\n    info.resource = resource;\n    const result = backend.runWebGPUProgram(program, [input], 'int32', uniformData);\n    backend.disposeData(input.dataId);\n    return result;\n  }\n  // TODO: Encoding should happen on GPU once we no longer have to download\n  // image data to the CPU.\n  const imageData = pixels.data;\n  let pixelArray = imageData;\n  if (numChannels != null && numChannels !== 4) {\n    pixelArray = new Uint8Array(pixels.width * pixels.height * numChannels);\n    const dataLength = imageData.length;\n    let j = 0;\n    for (let i = 0; i < dataLength; i++) {\n      if (i % 4 < numChannels) {\n        pixelArray[j++] = imageData[i];\n      }\n    }\n  }\n  const output = backend.makeTensorInfo(outputShape, 'int32', new Int32Array(pixelArray));\n  backend.uploadToGPU(output.dataId);\n  return output;\n}","map":{"version":3,"names":["env","FromPixels","util","FromPixelsProgram","fromPixelsConfig","kernelName","backendName","kernelFunc","fromPixels","fromPixels2DContext","willReadFrequently","getBool","args","inputs","backend","attrs","pixels","numChannels","Error","isVideo","HTMLVideoElement","isImage","HTMLImageElement","isCanvas","HTMLCanvasElement","OffscreenCanvas","isImageBitmap","ImageBitmap","width","height","videoWidth","videoHeight","outputShape","importVideo","isVideoOrImage","resource","device","importExternalTexture","source","newWillReadFrequently","document","createElement","getContext","canvas","drawImage","usage","GPUTextureUsage","COPY_DST","RENDER_ATTACHMENT","TEXTURE_BINDING","format","texture","textureManager","acquireTexture","queue","copyExternalImageToTexture","size","sizeFromShape","strides","computeStrides","program","uniformData","type","data","input","makeTensorInfo","info","tensorMap","get","dataId","result","runWebGPUProgram","disposeData","imageData","pixelArray","Uint8Array","dataLength","length","j","i","output","Int32Array","uploadToGPU"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/kernels/FromPixels.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use backend file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs, util} from '@tensorflow/tfjs-core';\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {FromPixelsProgram} from '../from_pixels_webgpu';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgpu',\n  kernelFunc: fromPixels as unknown as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\nlet willReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n\nexport function fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: WebGPUBackend,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  if (pixels == null) {\n    throw new Error('pixels passed to tf.browser.fromPixels() can not be null');\n  }\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const isCanvas = (typeof (HTMLCanvasElement) !== 'undefined' &&\n                    pixels instanceof HTMLCanvasElement) ||\n      (typeof (OffscreenCanvas) !== 'undefined' &&\n       pixels instanceof OffscreenCanvas);\n  const isImageBitmap =\n      typeof (ImageBitmap) !== 'undefined' && pixels instanceof ImageBitmap;\n\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n  const outputShape = [height, width, numChannels];\n\n  const importVideo =\n      env().getBool('WEBGPU_IMPORT_EXTERNAL_TEXTURE') && isVideo;\n  const isVideoOrImage = isVideo || isImage;\n  if (isImageBitmap || isCanvas || isVideoOrImage) {\n    let resource;\n    if (importVideo) {\n      resource = backend.device.importExternalTexture(\n          {source: pixels as HTMLVideoElement});\n    } else {\n      if (isVideoOrImage) {\n        const newWillReadFrequently =\n            env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n        if (fromPixels2DContext == null ||\n            newWillReadFrequently !== willReadFrequently) {\n          willReadFrequently = newWillReadFrequently;\n          fromPixels2DContext = document.createElement('canvas').getContext(\n              '2d', {willReadFrequently});\n        }\n        fromPixels2DContext.canvas.width = width;\n        fromPixels2DContext.canvas.height = height;\n        fromPixels2DContext.drawImage(\n            pixels as HTMLVideoElement | HTMLImageElement, 0, 0, width, height);\n        pixels = fromPixels2DContext.canvas;\n      }\n\n      const usage = GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING;\n      const format = 'rgba8unorm' as GPUTextureFormat;\n      const texture = backend.textureManager.acquireTexture(\n          outputShape[1], outputShape[0], format, usage);\n      backend.queue.copyExternalImageToTexture(\n          {source: pixels as HTMLCanvasElement | ImageBitmap}, {texture},\n          [outputShape[1], outputShape[0]]);\n      resource = texture;\n    }\n\n    const size = util.sizeFromShape(outputShape);\n    const strides = util.computeStrides(outputShape);\n    const program =\n        new FromPixelsProgram(outputShape, numChannels, importVideo);\n\n    const uniformData = [\n      {type: 'uint32', data: [size]}, {type: 'uint32', data: [numChannels]},\n      {type: 'uint32', data: [...strides]}\n    ];\n    const input = backend.makeTensorInfo([height, width], 'int32');\n    const info = backend.tensorMap.get(input.dataId);\n    info.resource = resource;\n\n    const result =\n        backend.runWebGPUProgram(program, [input], 'int32', uniformData);\n    backend.disposeData(input.dataId);\n    return result;\n  }\n\n  // TODO: Encoding should happen on GPU once we no longer have to download\n  // image data to the CPU.\n  const imageData = (pixels as ImageData | backend_util.PixelData).data;\n  let pixelArray = imageData;\n  if (numChannels != null && numChannels !== 4) {\n    pixelArray = new Uint8Array(pixels.width * pixels.height * numChannels);\n\n    const dataLength = imageData.length;\n    let j = 0;\n    for (let i = 0; i < dataLength; i++) {\n      if (i % 4 < numChannels) {\n        pixelArray[j++] = imageData[i];\n      }\n    }\n  }\n\n  const output =\n      backend.makeTensorInfo(outputShape, 'int32', new Int32Array(pixelArray));\n  backend.uploadToGPU(output.dataId);\n  return output;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}