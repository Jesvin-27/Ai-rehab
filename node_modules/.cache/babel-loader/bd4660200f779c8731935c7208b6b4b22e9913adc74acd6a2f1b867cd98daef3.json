{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { activationFnSnippet, biasActivationSnippet } from './activation_util';\nimport { makeMatMulPackedSource, makeMatMulPackedVec4Source } from './matmul_packed_webgpu';\nimport { typeSnippet } from './webgpu_program';\nimport { computeDispatch, computeWorkgroupSizeForConv2d, computeWorkPerThreadForConv2d } from './webgpu_util';\nfunction conv2dCommonSnippet(isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, activation = null, hasPreluActivationWeights = false, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4) {\n  const getXSnippet = innerElementSize => {\n    switch (innerElementSize) {\n      case 1:\n        return 'resData = f32(x[xIndex]);';\n      case 3:\n        return 'resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);';\n      case 4:\n        return 'resData = vec4<f32>(x[xIndex / 4]);';\n      default:\n        throw new Error(`innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n  const getWSnippet = innerElementSize => {\n    switch (innerElementSize) {\n      case 1:\n        return 'return f32(W[row * uniforms.wShape[3] + col]);';\n      case 4:\n        return 'return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);';\n      default:\n        throw new Error(`innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n  const coordASnippet = isChannelsLast ? `\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ` : `\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      `;\n  const coordResSnippet = isChannelsLast ? `\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ` : `\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      `;\n  const xHight = isChannelsLast ? 'uniforms.xShape[1]' : 'uniforms.xShape[2]';\n  const xWidth = isChannelsLast ? 'uniforms.xShape[2]' : 'uniforms.xShape[3]';\n  const row = isChannelsLast ? 'row' : 'col';\n  const col = isChannelsLast ? 'col' : 'row';\n  const readXSnippet = `\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${isChannelsLast ? 'uniforms.outShape[2]' : 'uniforms.outShape[3]'};\n      let outRow = ${row} / outWidth;\n      let outCol = ${row} % outWidth;\n\n      let WRow = ${col} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${col} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${col} % inChannels;\n      var resData = ${typeSnippet(innerElementSizeX)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${xHight} && xCol >= 0 && xCol < ${xWidth}) {\n        ${coordASnippet}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${getXSnippet(innerElementSizeX)}\n      }\n      return resData;`;\n  const sampleX = isChannelsLast ? fitAOuter && fitInner ? `\n      ${readXSnippet}` : `\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${readXSnippet}\n      }\n      return ${typeSnippet(innerElementSizeX)}(0.0);` : fitInner && fitBOuter ? `\n      ${readXSnippet}` : `\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${readXSnippet}\n      }\n      return ${typeSnippet(innerElementSizeX)}(0.0);`;\n  const sampleW = `${getWSnippet(innerElementSizeW)}`;\n  const resType = typeSnippet(innerElementSize);\n  const aType = isChannelsLast ? typeSnippet(innerElementSizeX) : typeSnippet(innerElementSizeW);\n  const bType = isChannelsLast ? typeSnippet(innerElementSizeW) : typeSnippet(innerElementSizeX);\n  const userCode = `\n      ${activationFnSnippet(activation, hasPreluActivationWeights, innerElementSize === 4, 4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${aType} {\n        ${isChannelsLast ? sampleX : sampleW}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${bType} {\n        ${isChannelsLast ? sampleW : sampleX}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${resType}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${isChannelsLast ? 'uniforms.outShape[2]' : 'uniforms.outShape[3]'};\n        ${coordResSnippet}\n        ${biasActivationSnippet(addBias, activation)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`;\n  return userCode;\n}\nexport class Conv2DMMProgram {\n  constructor(convInfo, dimAOuter, dimBOuter, dimInner, addBias = false, activation = null, hasPreluActivationWeights = false, sequentialAccessByThreads = false) {\n    this.variableNames = ['x', 'W'];\n    this.uniforms = `filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n    this.outputShape = convInfo.outShape;\n    this.isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    this.isVec4 = ((convInfo.inChannels % 4 === 0 || convInfo.inChannels % 3 === 0) && this.isChannelsLast || convInfo.outWidth % 4 === 0 && !this.isChannelsLast) && convInfo.outChannels % 4 === 0;\n    this.dispatchLayout = this.isChannelsLast ? {\n      x: [3],\n      y: [1, 2],\n      z: [0]\n    } : {\n      x: [2, 3],\n      y: [1],\n      z: [0]\n    };\n    this.workgroupSize = computeWorkgroupSizeForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);\n    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);\n    if (this.isVec4) {\n      this.outputComponent = 4;\n      if (this.isChannelsLast && convInfo.inChannels % 4 !== 0) {\n        this.innerElementSize = 3;\n        this.variableComponents = [1, 4];\n      } else {\n        this.innerElementSize = 4;\n        this.variableComponents = [4, 4];\n      }\n      if (addBias) {\n        this.variableNames.push('bias');\n        this.variableComponents.push(4);\n      }\n      if (hasPreluActivationWeights) {\n        this.variableNames.push('preluActivationWeights');\n        this.variableComponents.push(4);\n      }\n    } else {\n      this.innerElementSize = this.elementsPerThread[0];\n      if (addBias) {\n        this.variableNames.push('bias');\n      }\n      if (hasPreluActivationWeights) {\n        this.variableNames.push('preluActivationWeights');\n      }\n    }\n    this.sequentialAccessByThreads = sequentialAccessByThreads;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1];\n    this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0];\n    this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]);\n    this.fitAOuter = dimAOuter % this.tileAOuter === 0;\n    this.fitBOuter = dimBOuter % this.tileBOuter === 0;\n    this.fitInner = dimInner % this.tileInner === 0;\n    this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;\n  }\n  getUserCode() {\n    const matMulSource = this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, false, null, this.sequentialAccessByThreads);\n    const elementsSize = this.isVec4 ? [this.innerElementSize, 4, 4] : [1, 1, 1];\n    const userCode = `\n    ${conv2dCommonSnippet(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, elementsSize[0], elementsSize[1], elementsSize[2])}\n    ${matMulSource}\n  `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["activationFnSnippet","biasActivationSnippet","makeMatMulPackedSource","makeMatMulPackedVec4Source","typeSnippet","computeDispatch","computeWorkgroupSizeForConv2d","computeWorkPerThreadForConv2d","conv2dCommonSnippet","isChannelsLast","fitAOuter","fitBOuter","fitInner","addBias","activation","hasPreluActivationWeights","innerElementSizeX","innerElementSizeW","innerElementSize","getXSnippet","Error","getWSnippet","coordASnippet","coordResSnippet","xHight","xWidth","row","col","readXSnippet","sampleX","sampleW","resType","aType","bType","userCode","Conv2DMMProgram","constructor","convInfo","dimAOuter","dimBOuter","dimInner","sequentialAccessByThreads","variableNames","uniforms","outputShape","outShape","dataFormat","isVec4","inChannels","outWidth","outChannels","dispatchLayout","x","y","z","workgroupSize","elementsPerThread","dispatch","outputComponent","variableComponents","push","tileAOuter","tileBOuter","tileInner","Math","max","shaderKey","getUserCode","matMulSource","elementsSize"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/conv2d_mm_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {activationFnSnippet, biasActivationSnippet} from './activation_util';\nimport {makeMatMulPackedSource, makeMatMulPackedVec4Source} from './matmul_packed_webgpu';\nimport {typeSnippet, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, computeWorkgroupSizeForConv2d, computeWorkPerThreadForConv2d} from './webgpu_util';\n\nfunction conv2dCommonSnippet(\n    isChannelsLast: boolean, fitAOuter: boolean, fitBOuter: boolean,\n    fitInner: boolean, addBias = false,\n    activation: backend_util.Activation = null,\n    hasPreluActivationWeights = false, innerElementSizeX = 4,\n    innerElementSizeW = 4, innerElementSize = 4) {\n  const getXSnippet = (innerElementSize: number) => {\n    switch (innerElementSize) {\n      case 1:\n        return 'resData = f32(x[xIndex]);';\n      case 3:\n        return 'resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);';\n      case 4:\n        return 'resData = vec4<f32>(x[xIndex / 4]);';\n      default:\n        throw new Error(\n            `innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n  const getWSnippet = (innerElementSize: number) => {\n    switch (innerElementSize) {\n      case 1:\n        return 'return f32(W[row * uniforms.wShape[3] + col]);';\n      case 4:\n        return 'return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);';\n      default:\n        throw new Error(\n            `innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n  const coordASnippet = isChannelsLast ? `\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ` :\n                                         `\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      `;\n\n  const coordResSnippet = isChannelsLast ? `\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ` :\n                                           `\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      `;\n\n  const xHight = isChannelsLast ? 'uniforms.xShape[1]' : 'uniforms.xShape[2]';\n  const xWidth = isChannelsLast ? 'uniforms.xShape[2]' : 'uniforms.xShape[3]';\n  const row = isChannelsLast ? 'row' : 'col';\n  const col = isChannelsLast ? 'col' : 'row';\n  const readXSnippet = `\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${\n      isChannelsLast ? 'uniforms.outShape[2]' : 'uniforms.outShape[3]'};\n      let outRow = ${row} / outWidth;\n      let outCol = ${row} % outWidth;\n\n      let WRow = ${col} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${col} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${col} % inChannels;\n      var resData = ${typeSnippet(innerElementSizeX)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${xHight} && xCol >= 0 && xCol < ${xWidth}) {\n        ${coordASnippet}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${getXSnippet(innerElementSizeX)}\n      }\n      return resData;`;\n\n  const sampleX = isChannelsLast ? (fitAOuter && fitInner ? `\n      ${readXSnippet}` :\n                                                            `\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${readXSnippet}\n      }\n      return ${typeSnippet(innerElementSizeX)}(0.0);`) :\n                                   (fitInner && fitBOuter ? `\n      ${readXSnippet}` :\n                                                            `\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${readXSnippet}\n      }\n      return ${typeSnippet(innerElementSizeX)}(0.0);`);\n\n  const sampleW = `${getWSnippet(innerElementSizeW)}`;\n\n  const resType = typeSnippet(innerElementSize);\n  const aType = isChannelsLast ? typeSnippet(innerElementSizeX) :\n                                 typeSnippet(innerElementSizeW);\n  const bType = isChannelsLast ? typeSnippet(innerElementSizeW) :\n                                 typeSnippet(innerElementSizeX);\n  const userCode = `\n      ${\n      activationFnSnippet(\n          activation, hasPreluActivationWeights, innerElementSize === 4, 4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${aType} {\n        ${isChannelsLast ? sampleX : sampleW}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${bType} {\n        ${isChannelsLast ? sampleW : sampleX}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${resType}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${\n      isChannelsLast ? 'uniforms.outShape[2]' : 'uniforms.outShape[3]'};\n        ${coordResSnippet}\n        ${biasActivationSnippet(addBias, activation)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`;\n  return userCode;\n}\n\nexport class Conv2DMMProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  variableComponents: number[];\n  uniforms =\n      `filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n  workgroupSize: [number, number, number];\n  elementsPerThread: [number, number, number];\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  isChannelsLast: boolean;\n  fitAOuter: boolean;\n  fitBOuter: boolean;\n  fitInner: boolean;\n  tileAOuter: number;\n  tileBOuter: number;\n  tileInner: number;\n  innerElementSize: number;\n  isVec4?: boolean;\n  outputComponent: number;\n  private sequentialAccessByThreads: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, dimAOuter: number, dimBOuter: number,\n      dimInner: number, addBias = false,\n      activation: backend_util.Activation = null,\n      hasPreluActivationWeights = false, sequentialAccessByThreads = false) {\n    this.outputShape = convInfo.outShape;\n    this.isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    this.isVec4 =\n        (((convInfo.inChannels % 4 === 0 || convInfo.inChannels % 3 === 0) &&\n          this.isChannelsLast) ||\n         (convInfo.outWidth % 4 === 0 && !this.isChannelsLast)) &&\n        convInfo.outChannels % 4 === 0;\n    this.dispatchLayout = this.isChannelsLast ? {x: [3], y: [1, 2], z: [0]} :\n                                                {x: [2, 3], y: [1], z: [0]};\n    this.workgroupSize = computeWorkgroupSizeForConv2d(\n        this.dispatchLayout, this.outputShape, this.isVec4);\n    this.elementsPerThread = computeWorkPerThreadForConv2d(\n        this.dispatchLayout, this.outputShape, this.isVec4);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize,\n        this.elementsPerThread);\n\n    if (this.isVec4) {\n      this.outputComponent = 4;\n      if (this.isChannelsLast && convInfo.inChannels % 4 !== 0) {\n        this.innerElementSize = 3;\n        this.variableComponents = [1, 4];\n      } else {\n        this.innerElementSize = 4;\n        this.variableComponents = [4, 4];\n      }\n\n      if (addBias) {\n        this.variableNames.push('bias');\n        this.variableComponents.push(4);\n      }\n\n      if (hasPreluActivationWeights) {\n        this.variableNames.push('preluActivationWeights');\n        this.variableComponents.push(4);\n      }\n    } else {\n      this.innerElementSize = this.elementsPerThread[0];\n      if (addBias) {\n        this.variableNames.push('bias');\n      }\n\n      if (hasPreluActivationWeights) {\n        this.variableNames.push('preluActivationWeights');\n      }\n    }\n\n    this.sequentialAccessByThreads = sequentialAccessByThreads;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n\n    this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1];\n    this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0];\n    this.tileInner = Math.max(\n        this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]);\n\n    this.fitAOuter = dimAOuter % this.tileAOuter === 0;\n    this.fitBOuter = dimBOuter % this.tileBOuter === 0;\n    this.fitInner = dimInner % this.tileInner === 0;\n\n    this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${\n        this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${\n        this.innerElementSize}_${this.isChannelsLast}_${\n        this.sequentialAccessByThreads}`;\n  }\n\n  getUserCode(): string {\n    const matMulSource = this.isVec4 ?\n        makeMatMulPackedVec4Source(\n            this.elementsPerThread, this.workgroupSize, !this.isChannelsLast,\n            this.tileInner) :\n        makeMatMulPackedSource(\n            this.elementsPerThread, this.workgroupSize, !this.isChannelsLast,\n            this.tileInner, false, null, this.sequentialAccessByThreads);\n    const elementsSize =\n        this.isVec4 ? [this.innerElementSize, 4, 4] : [1, 1, 1];\n    const userCode = `\n    ${\n        conv2dCommonSnippet(\n            this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner,\n            this.addBias, this.activation, this.hasPreluActivationWeights,\n            elementsSize[0], elementsSize[1], elementsSize[2])}\n    ${matMulSource}\n  `;\n    return userCode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}