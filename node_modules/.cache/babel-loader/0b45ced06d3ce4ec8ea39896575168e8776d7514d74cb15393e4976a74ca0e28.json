{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { makeMatMulPackedSource, makeMatMulPackedVec4Source } from './matmul_packed_webgpu';\nimport { typeSnippet } from './webgpu_program';\nimport { computeDispatch, computeWorkgroupSizeForConv2d, computeWorkPerThreadForConv2d } from './webgpu_util';\nfunction conv2dTransposeCommonSnippet(innerElementSize = 4) {\n  const getWSnippet = innerElementSize => {\n    switch (innerElementSize) {\n      case 1:\n        return 'return W[getIndexFromCoords4D(coord, uniforms.wShape)];';\n      case 4:\n        return `\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;\n      default:\n        throw new Error(`innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n  const readASnippet = `\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${typeSnippet(innerElementSize)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${typeSnippet(innerElementSize)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${innerElementSize}];`;\n  const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${readASnippet}\n      }\n      return ${typeSnippet(innerElementSize)}(0.0);`;\n  const userCode = `\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${typeSnippet(innerElementSize)} {\n    ${sampleA}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${typeSnippet(innerElementSize)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${getWSnippet(innerElementSize)}\n    }\n    return ${typeSnippet(innerElementSize)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${typeSnippet(innerElementSize)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${innerElementSize}] = value;\n    }\n  }`;\n  return userCode;\n}\nexport class Conv2DDerInputMMProgram {\n  constructor(convInfo) {\n    this.variableNames = ['x', 'W'];\n    this.uniforms = 'filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,';\n    this.outputShape = convInfo.inShape;\n    util.assert(convInfo.dataFormat === 'channelsLast', () => 'TODO: NCHW is unimplemented');\n    this.isVec4 = convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;\n    this.dispatchLayout = {\n      x: [3],\n      y: [1, 2],\n      z: [0]\n    };\n    this.workgroupSize = computeWorkgroupSizeForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);\n    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);\n    if (this.isVec4) {\n      this.outputComponent = 4;\n      this.variableComponents = [4, 1];\n    }\n    this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;\n  }\n  getUserCode() {\n    const matMulSource = this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize);\n    const userCode = `\n    ${conv2dTransposeCommonSnippet(this.isVec4 ? 4 : 1)}\n    ${matMulSource}\n    `;\n    return userCode;\n  }\n}","map":{"version":3,"names":["util","makeMatMulPackedSource","makeMatMulPackedVec4Source","typeSnippet","computeDispatch","computeWorkgroupSizeForConv2d","computeWorkPerThreadForConv2d","conv2dTransposeCommonSnippet","innerElementSize","getWSnippet","Error","readASnippet","sampleA","userCode","Conv2DDerInputMMProgram","constructor","convInfo","variableNames","uniforms","outputShape","inShape","assert","dataFormat","isVec4","inChannels","outChannels","dispatchLayout","x","y","z","workgroupSize","elementsPerThread","dispatch","outputComponent","variableComponents","shaderKey","getUserCode","matMulSource"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/conv_backprop_mm_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {makeMatMulPackedSource, makeMatMulPackedVec4Source} from './matmul_packed_webgpu';\nimport {typeSnippet, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, computeWorkgroupSizeForConv2d, computeWorkPerThreadForConv2d} from './webgpu_util';\n\nfunction conv2dTransposeCommonSnippet(innerElementSize = 4) {\n  const getWSnippet = (innerElementSize: number) => {\n    switch (innerElementSize) {\n      case 1:\n        return 'return W[getIndexFromCoords4D(coord, uniforms.wShape)];';\n      case 4:\n        return `\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;\n      default:\n        throw new Error(\n            `innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n\n  const readASnippet = `\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${typeSnippet(innerElementSize)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${typeSnippet(innerElementSize)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${\n      innerElementSize}];`;\n\n  const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${readASnippet}\n      }\n      return ${typeSnippet(innerElementSize)}(0.0);`;\n\n  const userCode = `\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${\n      typeSnippet(innerElementSize)} {\n    ${sampleA}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${\n      typeSnippet(innerElementSize)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${getWSnippet(innerElementSize)}\n    }\n    return ${typeSnippet(innerElementSize)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${\n      typeSnippet(innerElementSize)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${\n      innerElementSize}] = value;\n    }\n  }`;\n  return userCode;\n}\n\nexport class Conv2DDerInputMMProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  variableComponents: number[];\n  uniforms =\n      'filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,';\n  workgroupSize: [number, number, number];\n  elementsPerThread: [number, number, number];\n  isVec4?: boolean;\n  outputComponent: number;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n    this.isVec4 =\n        convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;\n    this.dispatchLayout = {x: [3], y: [1, 2], z: [0]};\n    this.workgroupSize = computeWorkgroupSizeForConv2d(\n        this.dispatchLayout, this.outputShape, this.isVec4);\n    this.elementsPerThread = computeWorkPerThreadForConv2d(\n        this.dispatchLayout, this.outputShape, this.isVec4);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize,\n        this.elementsPerThread);\n\n    if (this.isVec4) {\n      this.outputComponent = 4;\n      this.variableComponents = [4, 1];\n    }\n\n    this.shaderKey =\n        `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;\n  }\n\n  getUserCode(): string {\n    const matMulSource = this.isVec4 ?\n        makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize) :\n        makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize);\n    const userCode = `\n    ${conv2dTransposeCommonSnippet(this.isVec4 ? 4 : 1)}\n    ${matMulSource}\n    `;\n    return userCode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}