{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Generates WGSL that computes strides.\nexport function symbolicallyComputeStrides(indicesArr, variableName) {\n  if (Math.max(...indicesArr) > 5) {\n    throw new Error('Cannot symbolically compute strides for rank > 6 tensor.');\n  }\n  const numCoords = indicesArr.length;\n  const indicesStr = 'xyzwuv';\n  const shape = indicesArr.map(d => `${variableName}.${indicesStr[d]}`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n  return strides;\n}\nexport const atomicAddSnippet = (ptr, v, type) => {\n  if (type === 'int32') {\n    return `atomicAdd(${ptr}, bitcast<i32>(${v}));`;\n  } else {\n    // atomicAdd only supports uint/int type. For float, we use\n    // atomicCompareExchangeWeak to simulate.\n    return `\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${v});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${ptr}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;\n  }\n};","map":{"version":3,"names":["symbolicallyComputeStrides","indicesArr","variableName","Math","max","Error","numCoords","length","indicesStr","shape","map","d","strides","Array","i","atomicAddSnippet","ptr","v","type"],"sources":["/Users/jesvinblazegmail.com/PycharmProjects/tfjs-backend-webgpu/src/shader_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Generates WGSL that computes strides.\nexport function symbolicallyComputeStrides(\n    indicesArr: number[], variableName: string): string[] {\n  if (Math.max(...indicesArr) > 5) {\n    throw new Error('Cannot symbolically compute strides for rank > 6 tensor.');\n  }\n\n  const numCoords = indicesArr.length;\n  const indicesStr = 'xyzwuv';\n  const shape = indicesArr.map(d => `${variableName}.${indicesStr[d]}`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n\nexport const atomicAddSnippet =\n    (ptr: string, v: string, type: 'int32'|'float32') => {\n      if (type === 'int32') {\n        return `atomicAdd(${ptr}, bitcast<i32>(${v}));`;\n      } else {\n        // atomicAdd only supports uint/int type. For float, we use\n        // atomicCompareExchangeWeak to simulate.\n        return `\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${v});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${ptr}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;\n      }\n    };\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA;AACA,OAAM,SAAUA,0BAA0BA,CACtCC,UAAoB,EAAEC,YAAoB;EAC5C,IAAIC,IAAI,CAACC,GAAG,CAAC,GAAGH,UAAU,CAAC,GAAG,CAAC,EAAE;IAC/B,MAAM,IAAII,KAAK,CAAC,0DAA0D,CAAC;;EAG7E,MAAMC,SAAS,GAAGL,UAAU,CAACM,MAAM;EACnC,MAAMC,UAAU,GAAG,QAAQ;EAC3B,MAAMC,KAAK,GAAGR,UAAU,CAACS,GAAG,CAACC,CAAC,IAAI,GAAGT,YAAY,IAAIM,UAAU,CAACG,CAAC,CAAC,EAAE,CAAC;EACrE,MAAMC,OAAO,GAAG,IAAIC,KAAK,CAACP,SAAS,GAAG,CAAC,CAAC;EACxCM,OAAO,CAACN,SAAS,GAAG,CAAC,CAAC,GAAGG,KAAK,CAACH,SAAS,GAAG,CAAC,CAAC;EAC7C,KAAK,IAAIQ,CAAC,GAAGR,SAAS,GAAG,CAAC,EAAEQ,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;IACvCF,OAAO,CAACE,CAAC,CAAC,GAAG,IAAIF,OAAO,CAACE,CAAC,GAAG,CAAC,CAAC,MAAML,KAAK,CAACK,CAAC,GAAG,CAAC,CAAC,GAAG;;EAGtD,OAAOF,OAAO;AAChB;AAEA,OAAO,MAAMG,gBAAgB,GACzBA,CAACC,GAAW,EAAEC,CAAS,EAAEC,IAAuB,KAAI;EAClD,IAAIA,IAAI,KAAK,OAAO,EAAE;IACpB,OAAO,aAAaF,GAAG,kBAAkBC,CAAC,KAAK;GAChD,MAAM;IACL;IACA;IACA,OAAO;;;;4DAI6CA,CAAC;;oDAETD,GAAG;;;;;;YAM3C;;AAER,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}